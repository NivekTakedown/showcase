<!doctype html><html lang=en-us dir=ltr><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="Geometría no euclidiana # Se denomina geometría no euclidiana a un sistema de geometría que no cumple con los postulados establecidas por Euclides:
dado dos puntos se puede trazar una sola recta que los une cualquier segmento puede prolongarse de manera continua en cualquier sentido se puede trazar una circunferencia con centro de cualquier punto y de cualquier radio todos los ángulos rectos son congruentes por un punto exterior a una recta se puede trazar una paralela (surge la geometría no euclidiana, hiperbólica-lobachevsky: existen varias paralelas, eliptica-riemann: no pasa una recta paralela."><meta name=theme-color content="#FFFFFF"><meta name=color-scheme content="light dark"><meta property="og:title" content><meta property="og:description" content="Geometría no euclidiana # Se denomina geometría no euclidiana a un sistema de geometría que no cumple con los postulados establecidas por Euclides:
dado dos puntos se puede trazar una sola recta que los une cualquier segmento puede prolongarse de manera continua en cualquier sentido se puede trazar una circunferencia con centro de cualquier punto y de cualquier radio todos los ángulos rectos son congruentes por un punto exterior a una recta se puede trazar una paralela (surge la geometría no euclidiana, hiperbólica-lobachevsky: existen varias paralelas, eliptica-riemann: no pasa una recta paralela."><meta property="og:type" content="article"><meta property="og:url" content="https://nivektakedown.github.io/showcase/docs/shortcodes/taller3/Taller3/"><meta property="article:section" content="docs"><meta property="article:modified_time" content="2022-11-29T05:24:45-05:00"><title>Taller3 | Showcase Template</title><link rel=manifest href=/showcase/manifest.json><link rel=icon href=/showcase/favicon.png type=image/x-icon><link rel=stylesheet href=/showcase/book.min.ab46de3e725a6415339a37bba23a0067534a37289b063c9f8d011515a63097a8.css integrity="sha256-q0bePnJaZBUzmje7ojoAZ1NKNyibBjyfjQEVFaYwl6g=" crossorigin=anonymous><script defer src=/showcase/flexsearch.min.js></script>
<script defer src=/showcase/en.search.min.4da9d90548d927573d3fe07ae0ccdb796f97e81f8e8ee7ed47b93dea2f822186.js integrity="sha256-TanZBUjZJ1c9P+B64MzbeW+X6B+OjuftR7k96i+CIYY=" crossorigin=anonymous></script></head><body dir=ltr><input type=checkbox class="hidden toggle" id=menu-control>
<input type=checkbox class="hidden toggle" id=toc-control><main class="container flex"><aside class=book-menu><div class=book-menu-content><nav><h2 class=book-brand><a class="flex align-center" href=/showcase/><span>Showcase Template</span></a></h2><div class=book-search><input type=text id=book-search-input placeholder=Search aria-label=Search maxlength=64 data-hotkeys=s/><div class="book-search-spinner hidden"></div><ul id=book-search-results></ul></div><ul><li class=book-section-flat><span>Shortcodes</span><ul><li><input type=checkbox id=section-282a92f5345e69a47740ccc543737088 class=toggle>
<label for=section-282a92f5345e69a47740ccc543737088 class="flex justify-between"><a href=/showcase/docs/shortcodes/taller1/>Taller1</a></label><ul><li><a href=/showcase/docs/shortcodes/taller1/ilusion_optica/>Ilusion Optica</a></li><li><a href=/showcase/docs/shortcodes/taller1/Masking/>Masking</a></li></ul></li><li><input type=checkbox id=section-266751ff1b6390cb9a365535ecf2c5c7 class=toggle>
<label for=section-266751ff1b6390cb9a365535ecf2c5c7 class="flex justify-between"><a href=/showcase/docs/shortcodes/taller2/>Taller2</a></label><ul><li><a href=/showcase/docs/shortcodes/taller2/3Dapp/>3 Dapp</a></li></ul></li><li><input type=checkbox id=section-e9dc4555d9802e3f4338ef612ad89fbb class=toggle checked>
<label for=section-e9dc4555d9802e3f4338ef612ad89fbb class="flex justify-between"><a href=/showcase/docs/shortcodes/taller3/>Taller3</a></label><ul><li><a href=/showcase/docs/shortcodes/taller3/Taller3/ class=active>Taller3</a></li></ul></li></ul></li></ul></nav><script>(function(){var e=document.querySelector("aside .book-menu-content");addEventListener("beforeunload",function(){localStorage.setItem("menu.scrollTop",e.scrollTop)}),e.scrollTop=localStorage.getItem("menu.scrollTop")})()</script></div></aside><div class=book-page><header class=book-header><div class="flex align-center justify-between"><label for=menu-control><img src=/showcase/svg/menu.svg class=book-icon alt=Menu></label>
<strong>Taller3</strong>
<label for=toc-control><img src=/showcase/svg/toc.svg class=book-icon alt="Table of Contents"></label></div><aside class="hidden clearfix"><nav id=TableOfContents><ul><li><a href=#geometría-no-euclidiana>Geometría no euclidiana</a></li><li><a href=#procedural-texturing>Procedural texturing</a></li><li><a href=#pixelator>pixelator</a></li><li><a href=#conclusiones>conclusiones</a><ul><li><a href=#referencias><strong>Referencias</strong></a></li></ul></li></ul></nav></aside></header><article class=markdown><h1 id=geometría-no-euclidiana>Geometría no euclidiana
<a class=anchor href=#geometr%c3%ada-no-euclidiana>#</a></h1><p>Se denomina geometría no euclidiana a un sistema de geometría que no cumple con los postulados establecidas por Euclides:</p><ul><li>dado dos puntos se puede trazar una sola recta que los une</li><li>cualquier segmento puede prolongarse de manera continua en cualquier sentido</li><li>se puede trazar una circunferencia con centro de cualquier punto y de cualquier radio</li><li>todos los ángulos rectos son congruentes</li><li>por un punto exterior a una recta se puede trazar una paralela (surge la geometría no euclidiana, hiperbólica-lobachevsky: existen varias paralelas, eliptica-riemann: no pasa una recta paralela.</li></ul><p>y en este trabajo lo podemos ver al crear un enlace entre dos espacios virtuales compartiendo un mismo punto de vista.</p><p>Para esto se crean 5 sesiones en p5 graphics, en las cuales se cargan los modelos 3D y una cámara que comparte punto de vista en las 5 sesiones, de estas sesiones lo que observa la cámara va a utilizarse como textura, estas se envían como texturas al fragment shader para posteriormente mapearse sobre una de las caras del cubo.</p><h1 id=procedural-texturing>Procedural texturing
<a class=anchor href=#procedural-texturing>#</a></h1><p>Una textura procedimental, es una textura que se crea a partir de un algoritmo, generando en tiempo real mediante este, en vez de ya estar almacenada directamente.
En este ejercicio la meta es crear una textura que se modifique en tiempo de ejecución siguiendo un algoritmo, para este ejercicio decidimos utilizar la ecuación del amor.
Para la solución de este ejercicio se adaptó un código del libro book of shaders, en el que se enseña las funciones que se pueden usar en un shader y cómo podemos hacer para crear movimiento con las uniforms y las varyings.</p><link rel=stylesheet href=/showcase/katex/katex.min.css><script defer src=/showcase/katex/katex.min.js></script>
<script defer src=/showcase/katex/auto-render.min.js onload=renderMathInElement(document.body)></script><span>
\[x^{2}+\left ( y- \sqrt[3]{x^{2}} \right )^{2}= 1\]</span><p>Esta representación no la podemos escribir en el fragment shader, esto porque podemos asignar una sola variable al tiempo. para solucionar este problemas se divide la ecuación en dos y queda como sigue:</p><span>\[y=\sqrt{1-x^2}+\sqrt[3]{x^2},\:y=-\sqrt{1-x^2}+\sqrt[3]{x^2} \]</span><p><details><summary>código software js</summary><div class=markdown-inner><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-html data-lang=html><span style=display:flex><span>let easycam;
</span></span><span style=display:flex><span>let edge = 160;
</span></span><span style=display:flex><span>let teapot;
</span></span><span style=display:flex><span>let teapotTex;
</span></span><span style=display:flex><span>let bunny;
</span></span><span style=display:flex><span>let bunnyTex;
</span></span><span style=display:flex><span>let tails;
</span></span><span style=display:flex><span>let tailsTex;
</span></span><span style=display:flex><span>let crash;
</span></span><span style=display:flex><span>let crashTex;
</span></span><span style=display:flex><span>let dio;
</span></span><span style=display:flex><span>let dioTex;
</span></span><span style=display:flex><span>let rex;
</span></span><span style=display:flex><span>let rexTex;
</span></span><span style=display:flex><span>let texShader;
</span></span><span style=display:flex><span>let miShader;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>let pg;
</span></span><span style=display:flex><span>let truchetShader;
</span></span><span style=display:flex><span>function preload() {
</span></span><span style=display:flex><span>  truchetShader = readShader(&#39;/showcase/sketches/taller3/shader2.frag&#39;,
</span></span><span style=display:flex><span>                             { matrices: Tree.NONE, varyings: Tree.NONE });
</span></span><span style=display:flex><span>  // no varyings need to be emitted from the vertex shader
</span></span><span style=display:flex><span>  texShader = readShader(&#39;/showcase/sketches/taller3/fragmentShader.frag&#39;,
</span></span><span style=display:flex><span>                         { varyings: Tree.NONE });
</span></span><span style=display:flex><span>  miShader = readShader(&#39;/showcase/sketches/taller3/shader2.frag&#39;,
</span></span><span style=display:flex><span>                         { varyings: Tree.NONE });
</span></span><span style=display:flex><span>  teapot = loadModel(&#39;/showcase/sketches/taller3/teapot.obj&#39;, true);
</span></span><span style=display:flex><span>  bunny = loadModel(&#39;/showcase/sketches/taller3/bunny.obj&#39;, true);
</span></span><span style=display:flex><span>  tails = loadModel(&#39;/showcase/sketches/taller3/Tails.obj&#39;, true);
</span></span><span style=display:flex><span>  crash = loadModel(&#39;/showcase/sketches/taller3/crash.obj&#39;, true);
</span></span><span style=display:flex><span>  dio = loadModel(&#39;/showcase/sketches/taller3/dio.obj&#39;, true);
</span></span><span style=display:flex><span>  rex = loadModel(&#39;/showcase/sketches/taller3/rex.obj&#39;, true);
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>function setup() {
</span></span><span style=display:flex><span>  createCanvas(800, 600, WEBGL);
</span></span><span style=display:flex><span>  // no need to normalize the texture
</span></span><span style=display:flex><span>  // textureMode(NORMAL);
</span></span><span style=display:flex><span>  shader(texShader);
</span></span><span style=display:flex><span>  // resolution will be used to sample the offscreen textures
</span></span><span style=display:flex><span>  emitResolution(texShader);
</span></span><span style=display:flex><span>  easycam = createEasyCam();
</span></span><span style=display:flex><span>  teapotTex = createGraphics(width, height, WEBGL);
</span></span><span style=display:flex><span>  bunnyTex = createGraphics(width, height, WEBGL);
</span></span><span style=display:flex><span>  tailsTex = createGraphics(width, height, WEBGL);
</span></span><span style=display:flex><span>  crashTex = createGraphics(width, height, WEBGL);
</span></span><span style=display:flex><span>  dioTex = createGraphics(width, height, WEBGL);
</span></span><span style=display:flex><span>  rexTex = createGraphics(width, height, WEBGL);
</span></span><span style=display:flex><span>  pg = createGraphics(width, height, WEBGL);
</span></span><span style=display:flex><span>  textureMode(NORMAL);
</span></span><span style=display:flex><span>  pg.noStroke();
</span></span><span style=display:flex><span>  pg.textureMode(NORMAL);
</span></span><span style=display:flex><span>  pg.background(255);
</span></span><span style=display:flex><span>  pg.reset();
</span></span><span style=display:flex><span>  pg.push();
</span></span><span style=display:flex><span>  truchetShader.setUniform(&#39;u_mouse&#39;, mouseX+0.0);
</span></span><span style=display:flex><span>  pg.shader(truchetShader);
</span></span><span style=display:flex><span>  // emitResolution, see:
</span></span><span style=display:flex><span>  // https://github.com/VisualComputing/p5.treegl#macros
</span></span><span style=display:flex><span>  pg.emitResolution(truchetShader);
</span></span><span style=display:flex><span>  // https://p5js.org/reference/#/p5.Shader/setUniform
</span></span><span style=display:flex><span>  truchetShader.setUniform(&#39;u_time&#39;, frameCount);
</span></span><span style=display:flex><span>  truchetShader.setUniform(&#39;u_mouse&#39;, mouseX+0.0);
</span></span><span style=display:flex><span>  // pg clip-space quad (i.e., both x and y vertex coordinates ∈ [-1..1])
</span></span><span style=display:flex><span>  pg.quad(-1, -1, 1, -1, 1, 1, -1, 1);
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>function draw() {
</span></span><span style=display:flex><span>  // 1. compute current main canvas camera params
</span></span><span style=display:flex><span>  let position = treeLocation();
</span></span><span style=display:flex><span>  let center = p5.Vector.add(position, treeDisplacement());
</span></span><span style=display:flex><span>  let up = treeDisplacement(Tree.j);
</span></span><span style=display:flex><span>  // in case the current camera projection params are needed check:
</span></span><span style=display:flex><span>  // https://github.com/VisualComputing/p5.treegl#frustum-queries
</span></span><span style=display:flex><span>  // 2. offscreen rendering
</span></span><span style=display:flex><span>  // bunny graphics
</span></span><span style=display:flex><span>  bunnyTex.background(200);
</span></span><span style=display:flex><span>  bunnyTex.reset();
</span></span><span style=display:flex><span>  bunnyTex.camera(position.x, position.y, position.z,
</span></span><span style=display:flex><span>                  center.x, center.y, center.z,
</span></span><span style=display:flex><span>                  up.x, up.y, up.z);
</span></span><span style=display:flex><span>  bunnyTex.push();
</span></span><span style=display:flex><span>  bunnyTex.noStroke();
</span></span><span style=display:flex><span>  bunnyTex.fill(&#39;red&#39;);
</span></span><span style=display:flex><span>  // most models use positive y-coordinates
</span></span><span style=display:flex><span>  bunnyTex.scale(1, -1);
</span></span><span style=display:flex><span>  bunnyTex.scale(0.8);// only bunny
</span></span><span style=display:flex><span>  bunnyTex.model(bunny);
</span></span><span style=display:flex><span>  bunnyTex.pop();
</span></span><span style=display:flex><span>  // teapot graphics
</span></span><span style=display:flex><span>  teapotTex.background(200);
</span></span><span style=display:flex><span>  teapotTex.reset();
</span></span><span style=display:flex><span>  teapotTex.camera(position.x, position.y, position.z,
</span></span><span style=display:flex><span>                   center.x, center.y, center.z,
</span></span><span style=display:flex><span>                   up.x, up.y, up.z);
</span></span><span style=display:flex><span>  teapotTex.push();
</span></span><span style=display:flex><span>  teapotTex.noStroke();
</span></span><span style=display:flex><span>  teapotTex.fill(&#39;blue&#39;);
</span></span><span style=display:flex><span>  teapotTex.scale(1, -1);
</span></span><span style=display:flex><span>  teapotTex.model(teapot);
</span></span><span style=display:flex><span>  teapotTex.pop();
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>  tailsTex.background(200);
</span></span><span style=display:flex><span>  tailsTex.reset();
</span></span><span style=display:flex><span>  tailsTex.camera(position.x, position.y, position.z,
</span></span><span style=display:flex><span>                  center.x, center.y, center.z,
</span></span><span style=display:flex><span>                  up.x, up.y, up.z);
</span></span><span style=display:flex><span>  tailsTex.push();
</span></span><span style=display:flex><span>  tailsTex.noStroke();
</span></span><span style=display:flex><span>  tailsTex.fill(&#39;orange&#39;);
</span></span><span style=display:flex><span>  // most models use positive y-coordinates
</span></span><span style=display:flex><span>  tailsTex.scale(1, -1);
</span></span><span style=display:flex><span>  tailsTex.model(tails);
</span></span><span style=display:flex><span>  tailsTex.pop()
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>  crashTex.background(200);
</span></span><span style=display:flex><span>  crashTex.reset();
</span></span><span style=display:flex><span>  crashTex.camera(position.x, position.y, position.z,
</span></span><span style=display:flex><span>                  center.x, center.y, center.z,
</span></span><span style=display:flex><span>                  up.x, up.y, up.z);
</span></span><span style=display:flex><span>  crashTex.push();
</span></span><span style=display:flex><span>  crashTex.noStroke();
</span></span><span style=display:flex><span>  crashTex.fill(&#39;orange&#39;);
</span></span><span style=display:flex><span>  // most models use positive y-coordinates
</span></span><span style=display:flex><span>  crashTex.scale(1, -1);
</span></span><span style=display:flex><span>  crashTex.model(crash);
</span></span><span style=display:flex><span>  crashTex.pop()
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>  dioTex.background(225);
</span></span><span style=display:flex><span>  dioTex.reset();
</span></span><span style=display:flex><span>  dioTex.camera(position.x, position.y, position.z,
</span></span><span style=display:flex><span>                  center.x, center.y, center.z,
</span></span><span style=display:flex><span>                  up.x, up.y, up.z);
</span></span><span style=display:flex><span>  dioTex.push();
</span></span><span style=display:flex><span>  dioTex.noStroke();
</span></span><span style=display:flex><span>  dioTex.fill(&#39;yellow&#39;);
</span></span><span style=display:flex><span>  // most models use positive y-coordinates
</span></span><span style=display:flex><span>  dioTex.scale(1, -1);
</span></span><span style=display:flex><span>  dioTex.model(dio);
</span></span><span style=display:flex><span>  dioTex.pop()
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>  rexTex.background(225);
</span></span><span style=display:flex><span>  rexTex.reset();
</span></span><span style=display:flex><span>  rexTex.camera(position.x, position.y, position.z,
</span></span><span style=display:flex><span>                  center.x, center.y, center.z,
</span></span><span style=display:flex><span>                  up.x, up.y, up.z);
</span></span><span style=display:flex><span>  rexTex.push();
</span></span><span style=display:flex><span>  rexTex.noStroke();
</span></span><span style=display:flex><span>  rexTex.fill(&#39;gray&#39;);
</span></span><span style=display:flex><span>  // most models use positive y-coordinates
</span></span><span style=display:flex><span>  rexTex.scale(1, -1);
</span></span><span style=display:flex><span>  rexTex.model(rex);
</span></span><span style=display:flex><span>  rexTex.pop()
</span></span><span style=display:flex><span>  // 3. main canvas
</span></span><span style=display:flex><span>  background(0);
</span></span><span style=display:flex><span>  push();
</span></span><span style=display:flex><span>  // front (+z)
</span></span><span style=display:flex><span>  stroke(&#39;purple&#39;);
</span></span><span style=display:flex><span>  strokeWeight(5);
</span></span><span style=display:flex><span>  texShader.setUniform(&#39;texture&#39;, bunnyTex);
</span></span><span style=display:flex><span>  beginShape();
</span></span><span style=display:flex><span>  vertex(+edge, +edge, -edge);
</span></span><span style=display:flex><span>  vertex(-edge, +edge, -edge);
</span></span><span style=display:flex><span>  vertex(-edge, +edge, +edge);
</span></span><span style=display:flex><span>  vertex(+edge, +edge, +edge);
</span></span><span style=display:flex><span>  endShape(CLOSE);
</span></span><span style=display:flex><span>  texShader.setUniform(&#39;texture&#39;, teapotTex);
</span></span><span style=display:flex><span>  beginShape();
</span></span><span style=display:flex><span>  vertex(-edge, -edge, +edge);
</span></span><span style=display:flex><span>  vertex(+edge, -edge, +edge);
</span></span><span style=display:flex><span>  vertex(+edge, -edge, -edge);
</span></span><span style=display:flex><span>  vertex(-edge, -edge, -edge);
</span></span><span style=display:flex><span>  endShape(CLOSE);
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>  texShader.setUniform(&#39;texture&#39;, dioTex);
</span></span><span style=display:flex><span>  beginShape();
</span></span><span style=display:flex><span>  vertex(-edge, -edge, +edge);
</span></span><span style=display:flex><span>  vertex(+edge, -edge, +edge);
</span></span><span style=display:flex><span>  vertex(+edge, +edge, +edge);
</span></span><span style=display:flex><span>  vertex(-edge, +edge, +edge);
</span></span><span style=display:flex><span>  endShape(CLOSE);
</span></span><span style=display:flex><span>  push();
</span></span><span style=display:flex><span>  shader(truchetShader);
</span></span><span style=display:flex><span>  truchetShader.setUniform(&#39;u_resolution&#39;, [width, height]);
</span></span><span style=display:flex><span>  truchetShader.setUniform(&#39;u_time&#39;, frameCount/100+0.0);
</span></span><span style=display:flex><span>  pg.quad(-1, -1, 1, -1, 1, 1, -1, 1);
</span></span><span style=display:flex><span>  texture(pg);
</span></span><span style=display:flex><span>  translate(0,0,-edge);
</span></span><span style=display:flex><span>  square(-edge, -edge, edge+edge);
</span></span><span style=display:flex><span>  pop();
</span></span><span style=display:flex><span>  texShader.setUniform(&#39;texture&#39;, crashTex);
</span></span><span style=display:flex><span>  beginShape();
</span></span><span style=display:flex><span>  vertex(+edge, -edge, +edge);
</span></span><span style=display:flex><span>  vertex(+edge, -edge, -edge);
</span></span><span style=display:flex><span>  vertex(+edge, +edge, -edge);
</span></span><span style=display:flex><span>  vertex(+edge, +edge, +edge);
</span></span><span style=display:flex><span>  endShape(CLOSE);
</span></span><span style=display:flex><span>  texShader.setUniform(&#39;texture&#39;, tailsTex);
</span></span><span style=display:flex><span>  beginShape();
</span></span><span style=display:flex><span>  vertex(-edge, +edge, -edge);
</span></span><span style=display:flex><span>  vertex(-edge, +edge, +edge);
</span></span><span style=display:flex><span>  vertex(-edge, -edge, +edge);
</span></span><span style=display:flex><span>  vertex(-edge, -edge, -edge);
</span></span><span style=display:flex><span>  endShape(CLOSE);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  pop();
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>  pop();
</span></span><span style=display:flex><span>}</span></span></code></pre></div></div></details><details><summary>código fragment shader Geometría no euclidiana</summary><div class=markdown-inner><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-html data-lang=html><span style=display:flex><span>precision mediump float;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>uniform sampler2D texture;
</span></span><span style=display:flex><span>uniform vec2 u_resolution;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>void main() {
</span></span><span style=display:flex><span>  vec2 st1 = gl_FragCoord.xy / u_resolution;
</span></span><span style=display:flex><span>  gl_FragColor = texture2D(texture, vec2(st1.x,(1.0-st1.y)));
</span></span><span style=display:flex><span>}</span></span></code></pre></div></div></details></p><details><summary>código fragment shader procedural texturing</summary><div class=markdown-inner><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-html data-lang=html><span style=display:flex><span>// Author:Kevin Fabio Ramos López
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>#ifdef GL_ES
</span></span><span style=display:flex><span>precision mediump float;
</span></span><span style=display:flex><span>#endif
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>#define PI 3.14159265359
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>uniform vec2 u_resolution;
</span></span><span style=display:flex><span>uniform vec2 u_mouse;
</span></span><span style=display:flex><span>uniform float u_time;
</span></span><span style=display:flex><span>uniform sampler2D tex;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>float plot(vec2 st, float pct){
</span></span><span style=display:flex><span>  return  smoothstep( pct-0.02, pct+0.02, st.y) -
</span></span><span style=display:flex><span>          smoothstep( pct+.02, pct+0.02, st.y);
</span></span><span style=display:flex><span>}//tomado de https://thebookofshaders.com/
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>void main() {
</span></span><span style=display:flex><span>  float a=2.75;
</span></span><span style=display:flex><span>  float time= 9.0;
</span></span><span style=display:flex><span>    vec2 st = gl_FragCoord.xy/u_resolution;
</span></span><span style=display:flex><span>    float x=st.x*(a+sin(u_time*time))-2.2-(-(cos(u_time*time)));
</span></span><span style=display:flex><span>    // Smooth interpolation between 0.1 and 0.9
</span></span><span style=display:flex><span>    float y = 0.89+(sqrt(-x*x+1.0)+pow(x*x, 1.0/ 3.0))/(a+sin(u_time*time));
</span></span><span style=display:flex><span>	float z = 0.9+(-sqrt(-x*x+1.0)+pow(x*x, 1.0/ 3.0))/(a+sin(u_time*time));
</span></span><span style=display:flex><span>    vec3 color = vec3(y);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    float pct = plot(st,y);
</span></span><span style=display:flex><span>    float pct2 = plot(st,z);
</span></span><span style=display:flex><span>    color = +pct*vec3(0.0,1.0,1.0)+pct2*vec3(0.0,1.0,1.0);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    gl_FragColor = vec4(.8,.8,.8,1.0)-vec4(color,abs(sin(u_time*time)));
</span></span><span style=display:flex><span>}</span></span></code></pre></div></div></details><iframe id=sketch style=width:800px;height:600px srcdoc="
        <!DOCTYPE html>
        <html>
          <head>
            <script src=https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.4.2/p5.min.js></script>
            <script src=https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.4.2/addons/p5.sound.min.js></script>
             <script src=https://cdn.jsdelivr.net/gh/VisualComputing/p5.treegl/p5.treegl.js></script> 
             <script src=https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.5.0/addons/p5.sound.min.js></script> 
             <script src=https://freshfork.github.io/p5.EasyCam/p5.easycam.js></script> 
             <script src=https://cdn.jsdelivr.net/gh/VisualComputing/p5.treegl/p5.treegl.js></script> 
            
            <script src=/showcase/sketches/taller3/sketch.js></script>
          </head>
          <body>
          </body>
        </html>
      "></iframe><h1 id=pixelator>pixelator
<a class=anchor href=#pixelator>#</a></h1><p>La coherencia es parcial es el fenómeno visual en el que los colores varían dependiendo de la distancia de la que se está observando, entre mayor distancia hay entre puntos es más probable que los colores de estos difieran.
En este ejercicio, se diseñará un pixelator, esta es una técnica que se encarga de reducir la resolución de una imagen (La resolución de una imagen indica la cantidad de detalles que puede observarse en esta), sin perder la coherencia (forma y diseño). Esto es posible, gracias a que las imágenes están creadas en un mapa de bits.
La vectorización primero crea una representación vectorial independiente de la resolución del gráfico que se va a escalar, guardando la posición de cada píxel. Digamos que tengo una imagen que quiero &ldquo;pixelar&rdquo;. Quiero esta imagen nítida representada por una cuadrícula de, digamos, 100 x 100 cuadrados. Entonces, si la foto original es de 500 px X 500 px, cada cuadrado es de 5 px X 5 px. Entonces, cada cuadrado tendría un color correspondiente al grupo de píxeles de 5 px X 5 px por el que se intercambia. El escalado de imágenes se puede interpretar como una forma de remuestreo de imágenes o reconstrucción de imágenes</p><details><summary>código fragment shader pixelator</summary><div class=markdown-inner><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-html data-lang=html><span style=display:flex><span>precision mediump float;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>varying vec2 vTexCoord;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>uniform sampler2D tex0;
</span></span><span style=display:flex><span>uniform float tiles;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>void main() {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  vec2 uv = vTexCoord;
</span></span><span style=display:flex><span>  uv = 1.0 - uv;
</span></span><span style=display:flex><span>  uv = floor(uv * tiles)/tiles;
</span></span><span style=display:flex><span>  vec4 tex = texture2D(tex0, uv);
</span></span><span style=display:flex><span>  gl_FragColor = tex;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  //ver cambio en la textura
</span></span><span style=display:flex><span>  //gl_FragColor = vec4(uv.x, uv.y, 0.0, 1.0);
</span></span><span style=display:flex><span>}</span></span></code></pre></div></div></details><details><summary>código vertex shader pixelator</summary><div class=markdown-inner><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-html data-lang=html><span style=display:flex><span>attribute vec3 aPosition;
</span></span><span style=display:flex><span>attribute vec2 aTexCoord;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>varying vec2 vTexCoord;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>void main() {
</span></span><span style=display:flex><span>  vTexCoord = aTexCoord;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  vec4 positionVec4 = vec4(aPosition, 1.0);
</span></span><span style=display:flex><span>  positionVec4.xy = positionVec4.xy * 2.0 - 1.0;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  gl_Position = positionVec4;
</span></span><span style=display:flex><span>}</span></span></code></pre></div></div></details><p><details><summary>código software js pixelator</summary><div class=markdown-inner><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-html data-lang=html><span style=display:flex><span>let imgShader;
</span></span><span style=display:flex><span>let resolution;
</span></span><span style=display:flex><span>let img1; let img2; let img3; let img4; let img5;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>let tab; //menu de seleccion
</span></span><span style=display:flex><span>let selec;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>function pickEvent() {
</span></span><span style=display:flex><span>    selec = tab.value();    
</span></span><span style=display:flex><span>    if (selec === &#39;-anya&#39;) {
</span></span><span style=display:flex><span>        selec = 1;
</span></span><span style=display:flex><span>    } else if (selec === &#39;-goku&#39;) {
</span></span><span style=display:flex><span>        selec = 2;
</span></span><span style=display:flex><span>    } else if (selec === &#39;-naruto&#39;) {
</span></span><span style=display:flex><span>        selec = 3;
</span></span><span style=display:flex><span>    } else if (selec === &#39;-konosuba&#39;) {
</span></span><span style=display:flex><span>        selec = 4;
</span></span><span style=display:flex><span>    } else if (selec === &#39;-shawson&#39;) {
</span></span><span style=display:flex><span>        selec = 5;
</span></span><span style=display:flex><span>    } 
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>function preload(){
</span></span><span style=display:flex><span>  imgShader = loadShader(&#39;/showcase/sketches/taller3/pixelator/effect.vert&#39;, &#39;/showcase/sketches/taller3/pixelator/effect.frag&#39;);
</span></span><span style=display:flex><span>  img1 = loadImage(&#34;/showcase/sketches/taller3/pixelator/anya.jpg&#34;);
</span></span><span style=display:flex><span>  img2 = loadImage(&#34;/showcase/sketches/taller3/pixelator/goku.jpg&#34;);
</span></span><span style=display:flex><span>  img3 = loadImage(&#34;/showcase/sketches/taller3/pixelator/naruto.jpg&#34;);
</span></span><span style=display:flex><span>  img4 = loadImage(&#34;/showcase/sketches/taller3/pixelator/konosuba.jpg&#34;);
</span></span><span style=display:flex><span>  img5 = loadImage(&#34;/showcase/sketches/taller3/pixelator/shawson.jpg&#34;);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>function setup() {
</span></span><span style=display:flex><span>  createCanvas(windowWidth, windowHeight, WEBGL);  
</span></span><span style=display:flex><span>  textureMode(NORMAL);
</span></span><span style=display:flex><span>  tab= createSelect();
</span></span><span style=display:flex><span>  tab.position(10, 10);
</span></span><span style=display:flex><span>  tab.option(&#39;Pixel&#39;);
</span></span><span style=display:flex><span>  tab.option(&#39;-anya&#39;);
</span></span><span style=display:flex><span>  tab.option(&#39;-goku&#39;);
</span></span><span style=display:flex><span>  tab.option(&#39;-konosuba&#39;);
</span></span><span style=display:flex><span>  tab.option(&#39;-naruto&#39;);
</span></span><span style=display:flex><span>  tab.option(&#39;-shawson&#39;);
</span></span><span style=display:flex><span>  tab.changed(pickEvent);
</span></span><span style=display:flex><span>  noStroke();
</span></span><span style=display:flex><span>  shader(imgShader);
</span></span><span style=display:flex><span>  resolution = createSlider(1, 300, 20, 1);
</span></span><span style=display:flex><span>  resolution.position(10, 35);
</span></span><span style=display:flex><span>  resolution.style(&#39;width&#39;, &#39;80px&#39;);
</span></span><span style=display:flex><span>  resolution.input(() =&gt; imgShader.setUniform(&#39;resolution&#39;, resolution.value()));
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>function draw() {  
</span></span><span style=display:flex><span>  if (selec == 1){
</span></span><span style=display:flex><span>    imgShader.setUniform(&#39;tex0&#39;, img1);
</span></span><span style=display:flex><span>  } else if (selec == 2){
</span></span><span style=display:flex><span>    imgShader.setUniform(&#39;tex0&#39;, img2);
</span></span><span style=display:flex><span>  } else if (selec == 3){
</span></span><span style=display:flex><span>    imgShader.setUniform(&#39;tex0&#39;, img3);
</span></span><span style=display:flex><span>  } else if (selec == 4){
</span></span><span style=display:flex><span>    imgShader.setUniform(&#39;tex0&#39;, img4);
</span></span><span style=display:flex><span>  } else if (selec == 5){
</span></span><span style=display:flex><span>    imgShader.setUniform(&#39;tex0&#39;, img5);
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  imgShader.setUniform(&#39;tiles&#39;, float(resolution.value()));
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  rect(0,0,width, height);
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>function windowResized(){
</span></span><span style=display:flex><span>  resizeCanvas(windowWidth, windowHeight);
</span></span><span style=display:flex><span>}</span></span></code></pre></div></div></details><iframe id=sketch style=width:800px;height:800px srcdoc="
        <!DOCTYPE html>
        <html>
          <head>
            <script src=https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.4.2/p5.min.js></script>
            <script src=https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.4.2/addons/p5.sound.min.js></script>
             <script src=https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.5.0/p5.js></script> 
             <script src=https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.5.0/addons/p5.sound.min.js></script> 
            
            
            
            <script src=/showcase/sketches/taller3/pixelator/sketch.js></script>
          </head>
          <body>
          </body>
        </html>
      "></iframe></p><h1 id=conclusiones>conclusiones
<a class=anchor href=#conclusiones>#</a></h1><ul><li>Una textura procedural se puede utilizar para modelar superficies volumétricas de elementos naturales, en videojuegos.</li><li>la geometría no euclidiana es un concepto más difícil de entender que de implementar
Los núcleos de la GPU no tienen memoria y no pueden saber lo que hacen otros núcleos, la información que utilizan para dibujar son las uniforms que es igual para todos y las varying que es la información que varía de uno a otro.</li><li>El escalado de imágenes es esencial como una de sus aplicaciones ya que es necesaria para el zoom</li><li>debido a que en un inicio los equipos no podían sostener una gran capacidad gráfica, se decidió recurrir al pixel art, como principal forma de generar una interfaz, hoy en día debido a su facilidad y bajo coste computacional, es una gran herramienta para desarrolladores y artistas</li></ul><h2 id=referencias><strong>Referencias</strong>
<a class=anchor href=#referencias>#</a></h2><ul><li><a href=https://thebookofshaders.com/>book of shaders</a></li><li><a href=https://es.wikipedia.org/wiki/Geometr%C3%ADa_no_euclidiana>Geometría no euclidiana</a></li><li><a href=https://sketchfab.com/3d-models/crash-bandicoot-442556bf988345afbbdc1f398c169a30#download>crash-bandicoot model</a></li><li><a href=https://sketchfab.com/3d-models/tails-obj-free-3d-model-7a79162d7da14bf49fc194f8cc9322f8>Tails model</a></li><li><a href=https://sketchfab.com/3d-models/dio-wry-pose-5dab629697204550af955b9994507923>dio-wry-pose model</a></li><li><a href=https://sketchfab.com/3d-models/metal-gear-rex-7078266ac0e7463db9093e0bbf9c59b1#download>metal-gear-rex model</a></li><li><a href=https://sketchfab.com/3d-models/super-mario-64-rigged-and-fixed-textures-c4016c4356e94a3cac7e54f5c7e5eb61>mario model</a></li><li><a href=https://en.wikipedia.org/wiki/Image_scaling>Image_scaling</a></li><li><a href=https://es.wikipedia.org/wiki/Imagen_de_mapa_de_bits>Imagen_de_mapa_de_bits</a></li></ul></article><footer class=book-footer><div class="flex flex-wrap justify-between"><div><a class="flex align-center" href=https://github.com/NivekTakedown/showcase.git/commit/e4714af81f07119a1f6e0ef2357a8e59eed95850 title='Last modified by nivektakedown | November 29, 2022' target=_blank rel=noopener><img src=/showcase/svg/calendar.svg class=book-icon alt=Calendar>
<span>November 29, 2022</span></a></div></div><script>(function(){function e(e){const t=window.getSelection(),n=document.createRange();n.selectNodeContents(e),t.removeAllRanges(),t.addRange(n)}document.querySelectorAll("pre code").forEach(t=>{t.addEventListener("click",function(){e(t.parentElement),navigator.clipboard&&navigator.clipboard.writeText(t.parentElement.textContent)})})})()</script></footer><div class=book-comments></div><label for=menu-control class="hidden book-menu-overlay"></label></div><aside class=book-toc><div class=book-toc-content><nav id=TableOfContents><ul><li><a href=#geometría-no-euclidiana>Geometría no euclidiana</a></li><li><a href=#procedural-texturing>Procedural texturing</a></li><li><a href=#pixelator>pixelator</a></li><li><a href=#conclusiones>conclusiones</a><ul><li><a href=#referencias><strong>Referencias</strong></a></li></ul></li></ul></nav></div></aside></main></body></html>