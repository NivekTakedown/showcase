[{"id":0,"href":"/showcase/docs/shortcodes/taller1/","title":"Taller1","section":"Shortcodes","content":" Taller 1 # p5 helps add p5 sketches into your book. There are two types of p5 shortcodes according to the html element used to embed them.\nTypes # Ilusion Optica Ilusiones ópticas # Una ilusión óptica es una ilusión que afecta a nuestro sistema visual haciendo que veamos la realidad de una manera distorsionada. Percepción de movimiento y profundidad # Estas ilusiones ópticas se basan en nuestra habilidad para reconocer el mundo, utiliza nuestra memoria visual para hacernos ver algo con ṕrofundidad, aun si lo que estamos viendo está solo en 2 dimensiones. O con movimiento, haciendo que algunos objetos se muevan más rápido que otros, tanto las animaciones como los videojuegos hacen uso de estas ilusiones. Masking Masking # Un kernel es una mask que se usa para aplicar filtros a una imagen. Estas máscaras tienen forma de matriz cuadrada, por lo que también se denominan matrices de convolución. Consideremos la matriz A, que representa la matriz que contiene los valores de gris de todos los píxeles de la imagen original, y la matriz B que representa la matriz kernel. Ahora superpongamos la matriz A con la matriz B, de modo que el centro de la matriz B corresponda al píxel de la matriz A que se procesará. "},{"id":1,"href":"/showcase/docs/shortcodes/taller1/ilusion_optica/","title":"Ilusion Optica","section":"Taller1","content":" Ilusiones ópticas # Una ilusión óptica es una ilusión que afecta a nuestro sistema visual haciendo que veamos la realidad de una manera distorsionada. Percepción de movimiento y profundidad # Estas ilusiones ópticas se basan en nuestra habilidad para reconocer el mundo, utiliza nuestra memoria visual para hacernos ver algo con ṕrofundidad, aun si lo que estamos viendo está solo en 2 dimensiones. O con movimiento, haciendo que algunos objetos se muevan más rápido que otros, tanto las animaciones como los videojuegos hacen uso de estas ilusiones. Look at this reference\nMoving picture # código moving picture {{\u0026lt; p5-global-iframe id=\u0026#34;breath\u0026#34; width=\u0026#34;625\u0026#34; height=\u0026#34;625\u0026#34; \u0026gt;}} // Coded as `global mode` of [this](https://github.com/VisualComputing/Cognitive/blob/gh-pages/sketches/rotateSquare.js) let x,y,c1,c2,c3,c4,c5,c6,c7,c8,c9,c10,c11,c12,c13,c14,c15,c16,c17,c18,c19, c20,c21,c22,c23,c24,c25,c26,c27,c28,c29,c30,c31,c32,c33,c34,c35; function setup(){ createCanvas(720,400); strokeWeight(2); x = width/2; y = height/2; c1=16*1;c2=16*2;c3=16*3;c4=16*4;c5=16*5;c6=16*6;c7=16*7;c8=16*8;c9=16*9; c10=16*10;c11=16*11;c12=16*12;c13=16*13;c14=16*14;c15=16*15;c16=16*16; c17=16*17;c18=16*18;c19=16*19;c20=16*20;c21=16*21;c22=16*22;c23=16*23; c24=16*24;c25=16*25;c26=16*26;c27=16*27;c28=16*28;c29=16*29;c30=16*30; c31=16*31;c32=16*32;c33=16*33;c34=16*34;c35=16*35; } function draw(){ background(\u0026#34;white\u0026#34;); //line(0,y,width,y); //line(x,0,x,height); fill(\u0026#39;red\u0026#39;); stroke(\u0026#39;red\u0026#39;); circle(x,y,5); stroke(\u0026#39;black\u0026#39;); cuadro(x,y,c1);cuadro(x,y,c2);cuadro(x,y,c3);cuadro(x,y,c4); cuadro(x,y,c5);cuadro(x,y,c6);cuadro(x,y,c7);cuadro(x,y,c8); cuadro(x,y,c9);cuadro(x,y,c10);cuadro(x,y,c11);cuadro(x,y,c12); cuadro(x,y,c13);cuadro(x,y,c14);cuadro(x,y,c15);cuadro(x,y,c16); cuadro(x,y,c17);cuadro(x,y,c18);cuadro(x,y,c19);cuadro(x,y,c20); cuadro(x,y,c21);cuadro(x,y,c22);cuadro(x,y,c23);cuadro(x,y,c24); cuadro(x,y,c25);cuadro(x,y,c26);cuadro(x,y,c27);cuadro(x,y,c28); cuadro(x,y,c29);cuadro(x,y,c30);cuadro(x,y,c31);cuadro(x,y,c32); cuadro(x,y,c33);cuadro(x,y,c34);cuadro(x,y,c35); c1+=16;c2+=16;c3+=16;c4+=16;c5+=16;c6+=16;c7+=16;c8+=16;c9+=16;c10+=16; c11+=16;c12+=16;c13+=16;c14+=16;c15+=16;c16+=16;c17+=16;c18+=16;c19+=16; c20+=16;c21+=16;c22+=16;c23+=16;c24+=16;c25+=16;c26+=16;c27+=16;c28+=16; c29+=16;c30+=16;c31+=16;c32+=16;c33+=16;c34+=16;c35+=16; if(c35 \u0026gt; 560){c35 = 0;}if(c34 \u0026gt; 560){c34 = 0;}if(c33 \u0026gt; 560){c33 = 0;} if(c32 \u0026gt; 560){c32 = 0;}if(c31 \u0026gt; 560){c31 = 0;}if(c30 \u0026gt; 560){c30 = 0;} if(c29 \u0026gt; 560){c29 = 0;}if(c28 \u0026gt; 560){c28 = 0;}if(c27 \u0026gt; 560){c27 = 0;} if(c26 \u0026gt; 560){c26 = 0;}if(c25 \u0026gt; 560){c25 = 0;}if(c24 \u0026gt; 560){c24 = 0;} if(c23 \u0026gt; 560){c23 = 0;}if(c22 \u0026gt; 560){c22 = 0;}if(c21 \u0026gt; 560){c21 = 0;} if(c20 \u0026gt; 560){c20 = 0;}if(c19 \u0026gt; 560){c19 = 0;}if(c18 \u0026gt; 560){c18 = 0;} if(c17 \u0026gt; 560){c17 = 0;}if(c16 \u0026gt; 560){c16 = 0;}if(c15 \u0026gt; 560){c15 = 0;} if(c14 \u0026gt; 560){c14 = 0;}if(c13 \u0026gt; 560){c13 = 0;}if(c12 \u0026gt; 560){c12 = 0;} if(c11 \u0026gt; 560){c11 = 0;}if(c10 \u0026gt; 560){c10 = 0;}if(c9 \u0026gt; 560){c9 = 0;} if(c8 \u0026gt; 560){c8 = 0;}if(c7 \u0026gt; 560){c7 = 0;}if(c6 \u0026gt; 560){c6 = 0;} if(c5 \u0026gt; 560){c5 = 0;}if(c4 \u0026gt; 560){c4 = 0;}if(c3 \u0026gt; 560){c3 = 0;} if(c2 \u0026gt; 560){c2 = 0;}if(c1 \u0026gt; 560){c1 = 0;} } function cuadro(x,y,ct){ line(x-ct,y,x,y-ct); line(x,y-ct,x+ct,y); line(x-ct,y,x,y+ct); line(x,y+ct,x+ct,y); } {{\u0026lt; /p5-global-iframe \u0026gt;}} Estrella # En este lugar se puede encontrar la ilusión óptica original: this reference\ncódigo estrella {{\u0026lt; p5-global-iframe id=\u0026#34;breath\u0026#34; width=\u0026#34;625\u0026#34; height=\u0026#34;625\u0026#34; \u0026gt;}} // Coded as `global mode` of [this](https://github.com/VisualComputing/Cognitive/blob/gh-pages/sketches/rotateSquare.js) let h; let w; let perc1; let perc2; let perc3; function setup() { createCanvas(400, 400); h=float(0.9); w=float(width/2); perc1=0.05; perc2=0.0125; perc3=0.1; } function draw() { background(220); let num = 26; let num1 = 1; while (num \u0026gt; 0) { if (num % 2==0) { fill(0,0,0); } else { fill(255,255,255) } num = num - 1; square(w*0.0125+w+perc1*w*num1/30,w*perc2+w+perc1*w*num1/30,w*h-num1); square(-w*perc2+(1-h)*w+perc3*w*num1/30,+w*perc2+w+perc1*w*num1/30,w*h-num1); square(w*perc2+w+perc1*w*num1/30,+w*0.085+perc3*w*num1/30,w*h-num1); square(-w*perc2+(1-h)*w+perc3*w*num1/30,+w*0.085+perc3*w*num1/30,w*h-num1); num1 = num1+ 7; } } {{\u0026lt; /p5-global-iframe \u0026gt;}} Estrella ajustable # En este lugar se puede encontrar la ilusión óptica original: this reference\ncódigo estrella {{\u0026lt; p5-global-iframe id=\u0026#34;breath\u0026#34; width=\u0026#34;625\u0026#34; height=\u0026#34;625\u0026#34; \u0026gt;}} // Coded as `global mode` of [this](https://github.com/VisualComputing/Cognitive/blob/gh-pages/sketches/rotateSquare.js) let h; let w; let perc1; let perc2; let perc3; let slider; let slider1; let slider2; function setup() { createCanvas(400, 400); h=float(0.9); w=float(width/2); slider=createSlider(0, 0.15, 0.03, 0.01); slider2=createSlider(0, 0.15, 0.12, 0.01); } function draw() { background(255); perc1 = slider.value(); perc2=0.0125; perc3=slider2.value(); let num = 26; let num1 = 1; while (num \u0026gt; 0) { if (num % 2==0) { fill(0,0,0); } else { fill(255,255,255) } num = num - 1; square(w*0.0125+w+perc1*w*num1/30,w*perc2+w+perc1*w*num1/30,w*h-num1); square(-w*perc2+(1-h)*w+perc3*w*num1/30,+w*perc2+w+perc1*w*num1/30,w*h-num1); square(w*perc2+w+perc1*w*num1/30,+w*0.085+perc3*w*num1/30,w*h-num1); square(-w*perc2+(1-h)*w+perc3*w*num1/30,+w*0.085+perc3*w*num1/30,w*h-num1); num1 = num1+ 7; } } {{\u0026lt; /p5-global-iframe \u0026gt;}} "},{"id":2,"href":"/showcase/docs/shortcodes/taller1/Masking/","title":"Masking","section":"Taller1","content":" Masking # Un kernel es una mask que se usa para aplicar filtros a una imagen. Estas máscaras tienen forma de matriz cuadrada, por lo que también se denominan matrices de convolución.\nConsideremos la matriz A, que representa la matriz que contiene los valores de gris de todos los píxeles de la imagen original, y la matriz B que representa la matriz kernel. Ahora superpongamos la matriz A con la matriz B, de modo que el centro de la matriz B corresponda al píxel de la matriz A que se procesará.\nEl valor de la imagen objetivo (matriz C) se calcula como la suma de todos los elementos de la matriz resultante del producto de Hadamard entre las matrices A y B.\nRecordamos que el producto de Hadamard es una operación binaria que toma dos matrices de la misma dimensione y produce otra matriz de igual dimensión, donde cada elemento i , j es el producto de los elementos i , j de las dos matrices originales\nLook at this reference for an explanation and further parameterization of the illusion.\ncódigo moving picture {{\u0026lt; p5-global-iframe id=\u0026#34;breath\u0026#34; width=\u0026#34;800\u0026#34; height=\u0026#34;600\u0026#34; \u0026gt;}} // Coded as `global mode` of [this](https://github.com/VisualComputing/Cognitive/blob/gh-pages/sketches/rotateSquare.js) let tab; //menu de seleccion let selec; let img; let c1=0;let c2=0;let c3=0;let c4=0; function setup() { var canvas = createCanvas(800,600); background(209); canvas.drop(gotFile); tab= createSelect(); tab.position(10, 10); tab.option(\u0026#39;Masking\u0026#39;); tab.option(\u0026#39;-gris\u0026#39;); tab.option(\u0026#39;-invert\u0026#39;); tab.option(\u0026#39;-threshold\u0026#39;); tab.option(\u0026#39;-blur\u0026#39;); tab.option(\u0026#39;-erode\u0026#39;); tab.option(\u0026#39;-dilate\u0026#39;); tab.option(\u0026#39;-sin filtro\u0026#39;); tab.changed(pickEvent); } function gotFile(file) { img = createImg(file.data); img.hide(); image(img,0,0,800,600); } function pickEvent() { selec = tab.value(); if (selec === \u0026#39;-gris\u0026#39;) { selec = 1; } else if (selec === \u0026#39;-invert\u0026#39;) { selec = 2; } else if (selec === \u0026#39;-threshold\u0026#39;) { selec = 3; } else if (selec === \u0026#39;-blur\u0026#39;) { selec = 4; } else if (selec === \u0026#39;-erode\u0026#39;) { selec = 5; } else if (selec === \u0026#39;-dilate\u0026#39;) { selec = 6; } else if (selec === \u0026#39;-sin filtro\u0026#39;) { selec = 0; } } function canva(){ createCanvas(800,600); background(209); image(img,0,0,800,600); } function draw(){ if (selec == 1){ c1=0;c2=0;c3=0;c4=0; canva(); filter(GRAY); //escala de grises } else if (selec == 2){ c1=0;c2=0;c3=0; c4 = c4+1; if (c4 == 1){ canva(); filter(INVERT); } } else if (selec == 3){ c1=0;c2=0;c3=0;c4=0; canva(); filter(THRESHOLD); //píxeles en blanco y negro umbral } else if (selec == 4){ c2=0;c3=0;c4=0; c1 = c1+1; if (c1 == 1){ canva(); filter(BLUR,3); //desenfoque } } else if (selec == 5){ c1=0;c3=0;c4=0; c2 = c2+1; if (c2 == 1){ canva(); filter(ERODE) //reduce las areas claras } } else if (selec == 6){ c2=0;c1=0;c4=0; c3 = c3+1; if (c3 == 1){ canva(); filter(DILATE ); //aumenta las areas claras } } else if (selec == 0){ c1=0;c2=0;c3=0;c4=0; canva(); } } {{\u0026lt; /p5-global-iframe \u0026gt;}} histograma de imagen # Un histograma de imagen, es un histograma que actúa como una representación gráfica de la distribución de tonos en la imagen, nos dice la influencia de cada uno de los colores a lo largo de toda la imagen. Para mostrar el histograma seleccionamos la imagen con el botón browse, mostramos la imagen con el botón izquierda y mostramos el histograma con el botón derecha.\ncódigo histograma {{\u0026lt; p5-global-iframe id=\u0026#34;breath\u0026#34; width=\u0026#34;800\u0026#34; height=\u0026#34;600\u0026#34; \u0026gt;}} let input; let img; let histogramR ; let histogramG ; let histogramB ; function setup() { createCanvas(800, 600); input = createFileInput(handleFile); input.position(0, 0); histogramR= []; histogramG= []; histogramB= []; for(let i = 0; i \u0026lt; 256; i++){ histogramR[i] = 0; histogramG[i] = 0; histogramB[i] = 0; } } function showHistogram(){ let j=0; for(let i = 0; i \u0026lt; 510; i++){ if(i%2==0){ fill(color(\u0026#34;red\u0026#34;)); stroke(color(\u0026#34;red\u0026#34;)); line(i,600,i,600-histogramR[j]); fill(color(\u0026#34;green\u0026#34;)); stroke(color(\u0026#34;green\u0026#34;)); line(i,600,i,600-histogramG[j]); fill(color(\u0026#34;blue\u0026#34;)); stroke(color(\u0026#34;blue\u0026#34;)); line(i,600,i,600-histogramB[j]); j++; } } } function keyPressed() { if (keyCode === LEFT_ARROW) { image(img, 0, 0, 800, 600); } else if (keyCode === RIGHT_ARROW) { Histogram(); showHistogram(); } } function handleFile(file) { print(file); if (file.type === \u0026#39;image\u0026#39;) { img = createImg(file.data, \u0026#39;\u0026#39;); img.hide(); } else { img = null; } } function Histogram(){ console.log(\u0026#34;hist\u0026#34;); for(let i = 0; i \u0026lt; 800; i=i+4){ for(let j = 0; j \u0026lt; 600; j=j+4){ let c=get(i, j); histogramR[c[0]] =histogramR[c[0]]+1; histogramG[c[1]] =histogramG[c[1]]+1; histogramB[c[2]] =histogramB[c[2]]+1; console.log(histogramR[c]); } } background(255); } {{\u0026lt; /p5-global-iframe \u0026gt;}} HSV y HSL # HSL y HSV, son representaciones alternativas del modelo de color RGB. La representación HSL modela la forma en que las diferentes pinturas se mezclan para crear color en el mundo real, con la dimensión de luminosidad que se asemeja a las cantidades variables de pintura negra o blanca en la mezcla. Mientras tanto, la representación de HSV modela cómo aparecen los colores bajo la luz. La diferencia entre HSL y HSV es que un color con máxima luminosidad en HSL es blanco puro, pero un color con máximo valor/brillo en HSV es similar a hacer brillar una luz blanca sobre un objeto de color. código cambio color {{\u0026lt; p5-global-iframe id=\u0026#34;breath\u0026#34; width=\u0026#34;625\u0026#34; height=\u0026#34;625\u0026#34; \u0026gt;}} var masterColor = {r: 0,g: 0,b: 0,h: 0,s: 0,v: 0,hs: 0,ss:0 ,l:0}; //toma de datos rgb let rSlider, gSlider, bSlider; let inpR, inpG, inpB; //variables hsb var hType = 0; var max = {colour: \u0026#34;-\u0026#34;,value: 0}; var min = {colour: \u0026#34;-\u0026#34;,value: 0}; function setup() { //background(50); //no funciona (╥_╥) createCanvas(800, 600); setUpRGBpicker(0, 0); } function draw() { drawRGBpicker(0, 0); drawHSVpicker(200, 0); drawHSLpicker(400,0); calHSV(); } function setUpRGBpicker(x, y) { rSlider = createSlider(0, 255, random(255)); rSlider.position(x + 15, y + 200); gSlider = createSlider(0, 255, random(255)); gSlider.position(x + 15, y + 230); bSlider = createSlider(0, 255, random(255)); bSlider.position(x + 15, y + 260); inpR = createInput(rSlider.value(), \u0026#34;number\u0026#34;); inpR.position(x + 150, y + 200); inpR.size(40, 20); inpG = createInput(gSlider.value(), \u0026#34;number\u0026#34;); inpG.position(x + 150, y + 230); inpG.size(40, 20); inpB = createInput(bSlider.value(), \u0026#34;number\u0026#34;); inpB.position(x + 150, y + 260); inpB.size(40, 20); rSlider.input(valueUpdate.bind(null, inpR, rSlider)); inpR.input(valueUpdate.bind(null, rSlider, inpR)); gSlider.input(valueUpdate.bind(null, inpG, gSlider)); inpG.input(valueUpdate.bind(null, gSlider, inpG)); bSlider.input(valueUpdate.bind(null, inpB, bSlider)); inpB.input(valueUpdate.bind(null, bSlider, inpB)); } function drawRGBpicker(x, y) { colorMode(RGB, 255); noStroke(); fill(rSlider.value(), gSlider.value(), bSlider.value()); rect(x + 20, y + 20, 160, 160); //color de las filas fill(255, 0, 0); rect(rSlider.x, rSlider.y, rSlider.width + 5, rSlider.height + 5); fill(0, 255, 0); rect(gSlider.x, gSlider.y, gSlider.width + 5, gSlider.height + 5); fill(0, 0, 255); rect(bSlider.x, bSlider.y, bSlider.width + 5, bSlider.height + 5); // masterColor.r = map(rSlider.value(), 0, 255, 0, 1); masterColor.g = map(gSlider.value(), 0, 255, 0, 1); masterColor.b = map(bSlider.value(), 0, 255, 0, 1); } function drawHSVpicker(x, y) { colorMode(HSB, 100); map(masterColor.s,0,1,0,100) fill(map(masterColor.h,0,1,0,360), map(masterColor.s,0,1,0,100), map(masterColor.v,0,1,0,100)); rect(x + 20, y + 20, 160, 160); } function drawHSLpicker(x,y){ //colorMode(HSL, 100); let c = color(masterColor.r, masterColor.g, masterColor.b); masterColor.hs = floor( hue(c) ); masterColor.ss = saturation(c); masterColor.l = lightness(c); console.log(masterColor); fill( `hsl(${ map(masterColor.hs,0,1,0,360) }, ${map(masterColor.ss,0,1,0,100) }%, ${map(masterColor.l,0,1,0,100)}%)` ); rect(x+20,y+20,160,160); } function calHSV() { masterColor.s = (maxRGB() - minRGB()) / maxRGB(); if (isNaN(masterColor.s)) { masterColor.s = 0; } masterColor.v = maxRGB(); var dr = (maxRGB() - masterColor.r) / maxRGB() - minRGB(); var dg = (maxRGB() - masterColor.g) / maxRGB() - minRGB(); var db = (maxRGB() - masterColor.b) / maxRGB() - minRGB(); if (masterColor.s == 0) { masterColor.h = 0; hType = 0; } else if (masterColor.r == maxRGB() \u0026amp;\u0026amp; masterColor.g == minRGB()) { masterColor.h = 5 + db; hType = 1; } else if (masterColor.r == maxRGB() \u0026amp;\u0026amp; masterColor.g != minRGB()) { masterColor.h = 1 - dg; hType = 2; } else if (masterColor.g == maxRGB() \u0026amp;\u0026amp; masterColor.b == minRGB()) { masterColor.h = dr + 1; hType = 3; } else if (masterColor.g == maxRGB() \u0026amp;\u0026amp; masterColor.b != minRGB()) { masterColor.h = 3 - db; hType = 4; } else if (masterColor.r == maxRGB()) { masterColor.h = 3 + dg; hType = 5; } else { masterColor.h = 5 - dr; hType = 6; } masterColor.h = masterColor.h * 60; } function valueUpdate(a, b, c) { a.value(b.value()); } function maxRGB() { var r = masterColor.r; var g = masterColor.g; var b = masterColor.b; var temp = Math.max(Math.max(r, g), b); if (temp == r) { max.colour = \u0026#34;r\u0026#34;; max.value = r; } else if (temp == g) { max.colour = \u0026#34;g\u0026#34;; max.value = g; } else if (temp == b) { max.colour = \u0026#34;b\u0026#34;; max.value = b; } return temp; } function minRGB() { var r = masterColor.r; var g = masterColor.g; var b = masterColor.b; var temp = Math.min(Math.min(r, g), b); if (temp == r) { min.colour = \u0026#34;r\u0026#34;; min.value = r; } else if (temp == g) { min.colour = \u0026#34;g\u0026#34;; min.value = g; } else if (temp == b) { min.colour = \u0026#34;b\u0026#34;; min.value = b; } return temp; } {{\u0026lt; /p5-global-iframe \u0026gt;}} Después de seleccionar la imagen, la cargamos oprimiendo la tecla hacia arriba y para cambiar a la representación HSV oprimimos la tecla derecha y para HSL la tecla izquierda. código cargar img HSV y HSL {{\u0026lt; p5-global-iframe id=\u0026#34;breath\u0026#34; width=\u0026#34;625\u0026#34; height=\u0026#34;625\u0026#34; \u0026gt;}} var masterColor = {r: 0,g: 0,b: 0,h: 0,s: 0,v: 0}; //variables hsb let input; let img; let R ; let G ; let B ; var hType = 0; var max = {colour: \u0026#34;-\u0026#34;,value: 0}; var min = {colour: \u0026#34;-\u0026#34;,value: 0}; function setup() { createCanvas(400,200); input = createFileInput(handleFile); input.position(0, 0); R= [];G= [];B= []; for(let i = 0; i \u0026lt; 80000; i++){ R[i] = 0; G[i] = 0; B[i] = 0; } } function keyPressed() { if (keyCode === UP_ARROW) { //imagen normal image(img,0,0,400,200); Histogram(); } else if (keyCode === RIGHT_ARROW) { //imagen en HSV drawHSV(); } else if (keyCode === LEFT_ARROW) { //imagen en HSL drawHSL(); } } function handleFile(file) { print(file); if (file.type === \u0026#39;image\u0026#39;) { img = createImg(file.data, \u0026#39;\u0026#39;); img.hide(); } else { img = null; } } function Histogram(){ for(let i = 0; i \u0026lt; 400; i++){ for(let j = 0; j \u0026lt; 200; j++){ let c=get(i, j); R[c[0]] =R[c[0]]+1; G[c[1]] =G[c[1]]+1; B[c[2]] =B[c[2]]+1; } } } function drawHSV() { let j=0; let x=0; let y=0; for(let i = 0; i \u0026lt; 80000; i++){ masterColor.r = R[j]; masterColor.g = G[j]; masterColor.b = B[j]; calHSV(); strokeWeight(0); fill(masterColor.h, masterColor.s, masterColor.v); rect(x,y,1,1); j++; if(x\u0026gt;400){ y+=2 x=0; } x+=2; } } function drawHSL(){ let j=0; let c; let x=0; let y=0; for(let i = 0; i \u0026lt; 80000; i++){ masterColor.r = R[j]; masterColor.g = G[j]; masterColor.b = B[j]; strokeWeight(0); c = color(masterColor.r, masterColor.g, masterColor.b); fill( `hsl(${ floor(hue(c))}, ${saturation(c)}%, ${lightness(c)}%)` ); rect(x,y,1,1); j++; if(x\u0026gt;400){ y+=2 x=0; } x+=2; } } function calHSV() { masterColor.s = (maxRGB() - minRGB()) / maxRGB(); if (isNaN(masterColor.s)) { masterColor.s = 0; } masterColor.v = maxRGB(); var dr = (maxRGB() - masterColor.r) / maxRGB() - minRGB(); var dg = (maxRGB() - masterColor.g) / maxRGB() - minRGB(); var db = (maxRGB() - masterColor.b) / maxRGB() - minRGB(); if (masterColor.s == 0) { masterColor.h = 0; hType = 0; } else if (masterColor.r == maxRGB() \u0026amp;\u0026amp; masterColor.g == minRGB()) { masterColor.h = 5 + db; hType = 1; } else if (masterColor.r == maxRGB() \u0026amp;\u0026amp; masterColor.g != minRGB()) { masterColor.h = 1 - dg; hType = 2; } else if (masterColor.g == maxRGB() \u0026amp;\u0026amp; masterColor.b == minRGB()) { masterColor.h = dr + 1; hType = 3; } else if (masterColor.g == maxRGB() \u0026amp;\u0026amp; masterColor.b != minRGB()) { masterColor.h = 3 - db; hType = 4; } else if (masterColor.r == maxRGB()) { masterColor.h = 3 + dg; hType = 5; } else { masterColor.h = 5 - dr; hType = 6; } masterColor.h = masterColor.h * 60; } function maxRGB() { var r = masterColor.r; var g = masterColor.g; var b = masterColor.b; var temp = Math.max(Math.max(r, g), b); if (temp == r) { max.colour = \u0026#34;r\u0026#34;; max.value = r; } else if (temp == g) { max.colour = \u0026#34;g\u0026#34;; max.value = g; } else if (temp == b) { max.colour = \u0026#34;b\u0026#34;; max.value = b; } return temp; } function minRGB() { var r = masterColor.r; var g = masterColor.g; var b = masterColor.b; var temp = Math.min(Math.min(r, g), b); if (temp == r) { min.colour = \u0026#34;r\u0026#34;; min.value = r; } else if (temp == g) { min.colour = \u0026#34;g\u0026#34;; min.value = g; } else if (temp == b) { min.colour = \u0026#34;b\u0026#34;; min.value = b; } return temp; } {{\u0026lt; /p5-global-iframe \u0026gt;}} Referencias # Making Filters Using p5.js! Kernel convolution Histograma filter histograma HCL Y HSL HCL Y HSL "},{"id":3,"href":"/showcase/docs/shortcodes/taller2/3Dapp/","title":"3 Dapp","section":"Taller2","content":" Aplicación en 3d 1 # El juego consiste en llevar la bola hasta el final de la pista, al finalizar nos mostrará el tiempo que nos demoramos en llegar a la meta, para movernos hacia adelante, hacia la izquierda y hacia la derecha oprimimos las teclas w,a y d. Al iniciar habrán 3 barras, la primera indica el largo de la pista, la segunda el alto de los obstáculos y la tercera la distancia entre estos. Una vez ya hemos cuadrado estos parámetros presionamos enter y el juego arrancará.\ncódigo juego bola {{\u0026lt; p5-global-iframe id=\u0026#34;breath\u0026#34; width=\u0026#34;625\u0026#34; height=\u0026#34;625\u0026#34; \u0026gt;}} let inicio=0; let myFont; function preload() { myFont = loadFont(\u0026#39;/showcase/sketches/taller2/assets/a.otf\u0026#39;); } //###estos datos se deben poder cambiar### let cam; let slider1; let slider2; let slider3; let dis = 0; //distancia de pista let ancho = 0; //ancho de cada rectangulos 10\u0026lt;=,\u0026lt;dis let largo = 0; //distancia entre rectangulos 16\u0026lt;=\u0026lt;dis //tiempo let sec1=0;let sec2=0; let min1=0;let min2=0; let tiempo=0; //extremos de cada figura en z let f1p1=0;let f1p2=0; let f2p1=0;let f2p2=0; let f3p1=0;let f3p2=0; //posicion de la esfera var x = 0; var z = 0; //posiciones de rectangulos esfera var posinf = 0; var posup =0; var figure = 1; //figura que se esta pasando. //calculamos las posiciones inciales de cada tipo de rectangulo function pos(p){ f1p1 = p-largo; f1p2 = f1p1-ancho; f2p1 = f1p2-largo; f2p2 = f2p1-ancho; f3p1 = f2p2-largo; f3p2 = f3p1-ancho; } function setup(){ createCanvas(700,700,WEBGL); slider1 = createSlider(100,3000,600); slider1.position(10,20); slider2 = createSlider(10,40,20); slider2.position(10,60); slider3 = createSlider(16,800,50); slider3.position(10,100); cam= createCamera(); } function juego(){ background(175); ambientLight(255); pointLight(255,255,255,0,-200,200) //###objeto### push(); translate(x,-10,z); sphere(10); pop(); //#####pista#### while((f1p1\u0026gt;-(dis/2))\u0026amp;\u0026amp;(f1p2\u0026gt;-(dis/2))){ //figura1 push(); translate(15,-(ancho/2),f1p1-(ancho/2)) box(70,ancho); pop(); //figura2 if ((f2p1\u0026gt;-(dis/2))\u0026amp;\u0026amp;(f2p2\u0026gt;-(dis/2))){ push(); translate(-15,-(ancho/2),f2p1-(ancho/2)) box(70,ancho); pop(); } //figura3 if ((f3p1\u0026gt;-(dis/2))\u0026amp;\u0026amp;(f3p2\u0026gt;-(dis/2))){ push(); translate(-32.5,-(ancho/2),f3p1-(ancho/2)) box(35,ancho); pop(); push(); translate(32.5,-(ancho/2),f3p1-(ancho/2)) box(35,ancho); pop(); } //crear la siguiente linea de figuras pos(f3p2); } if (f1p1\u0026lt;-(dis/2)){ pos(dis/2); } //movimiento de la esfera segun las teclas if (keyIsPressed) { if (z\u0026gt;-(dis/2)){ if (keyCode == 68) { x+=5 if (x==55){x=50;} //limite derecho de la pista else if ((figure==1)\u0026amp;\u0026amp;(x\u0026gt;=-25)\u0026amp;\u0026amp;((posinf\u0026gt;z)\u0026amp;\u0026amp;(posup\u0026lt;z))){x=-20} //comprubea parte derecha figura1 else if ((figure==3)\u0026amp;\u0026amp;(x\u0026gt;=20)\u0026amp;\u0026amp;((posinf\u0026gt;z)\u0026amp;\u0026amp;(posup\u0026lt;z))){x=15} //comprubea parte derecha figura3 } else if (keyCode == 65) { x-=5 if (x===-55){x=-50;} //limite izquierdo de la pista else if ((figure==2)\u0026amp;\u0026amp;(x\u0026lt;=15)\u0026amp;\u0026amp;((posinf\u0026gt;z)\u0026amp;\u0026amp;(posup\u0026lt;z))){x=20} //comprubea parte izquierda figura1 else if ((figure==3)\u0026amp;\u0026amp;(x\u0026lt;=-20)\u0026amp;\u0026amp;((posinf\u0026gt;z)\u0026amp;\u0026amp;(posup\u0026lt;z))){x=-15} //comprubea parte derecha figura3 } else if (keyCode == 87) { z-=5 //empieza el reloj if (z==(dis/2)-5){ sec1=second(); min1=minute(); } //rotateZ(45); if (z===((-dis/2)+5)){z=-dis/2;} //limite superior de la pista else if ((figure==1)\u0026amp;\u0026amp;((posup\u0026lt;z)\u0026amp;\u0026amp;(z\u0026lt;=posinf+5))\u0026amp;\u0026amp;((-20\u0026lt;x)\u0026amp;\u0026amp;(x\u0026lt;=50))){z=posinf} //limite superior de la figura1 else if ((figure==2)\u0026amp;\u0026amp;((posup\u0026lt;z)\u0026amp;\u0026amp;(z\u0026lt;=posinf+5))\u0026amp;\u0026amp;((-50\u0026lt;=x)\u0026amp;\u0026amp;(x\u0026lt;20))){z=posinf} //limite superior de la figura 2 else if ((figure==3)\u0026amp;\u0026amp;((posup\u0026lt;z)\u0026amp;\u0026amp;(z\u0026lt;=posinf+5))\u0026amp;\u0026amp;(((-50\u0026lt;=x)\u0026amp;\u0026amp;(x\u0026lt;-15))||((15\u0026lt;x)\u0026amp;\u0026amp;(x\u0026lt;=50)))){z=posinf} //limite superior de la figura 3 if (z\u0026lt;posup \u0026amp;\u0026amp; figure==1){ figure = 2; posinf = posup-largo; posup = posinf-ancho; } if (z\u0026lt;posup \u0026amp;\u0026amp; figure==2){ figure = 3; posinf = posup-largo; posup = posinf-ancho; } if (z\u0026lt;posup \u0026amp;\u0026amp; figure==3){ figure = 1; posinf = posup-largo; posup = posinf-ancho; } if(z!=posinf){ cam.move(0,0,-5); } } } //finaliza el reloj else if(z==(-dis/2)){ sec2=second(); min2=minute(); if (min2==min1){ tiempo=sec2-sec1; //numero de segundo que tardo en completarlo } else if(min2==min1+1){ tiempo=(60-sec1)+sec2; } else if (min2 \u0026gt; min1){ tiempo=(60-sec1)+(60*(min2-2))+sec2; } minutos=Math.floor(tiempo/60); segundos=tiempo%60; push() translate(0,-50,z-60) textSize(30); textFont(myFont); text(\u0026#34;tiempo:\\n \\t \u0026#34;+minutos+\u0026#34;:\u0026#34;+segundos,-50,-50); pop() noLoop(); } } //plataforma de pista translate(0,0); rotateX(HALF_PI); ambientMaterial(100); plane(100,dis) } function draw(){ background(220); if (keyCode == ENTER\u0026amp;\u0026amp;inicio==0){ inicio=1; dis = slider1.value(); ancho = slider2.value(); largo = slider3.value(); pos(dis/2); cam.move(0,-100,dis/2-300) z = dis/2; posinf = (dis/2)-largo; posup = posinf-ancho; } if(inicio==1){ juego(); } } {{\u0026lt; /p5-global-iframe \u0026gt;}} Aplicación en 3d 2 # para mover el vehículo hacia la izquierda oprimimos la tecla izquierda y para moverlo a la derecha la derecha, el vehículo se mueve automáticamente hacia adelante. código juego carro {{\u0026lt; p5-global-iframe id=\u0026#34;breath\u0026#34; width=\u0026#34;625\u0026#34; height=\u0026#34;625\u0026#34; \u0026gt;}} let cam; let j=0; let i=0; let k=0; let img; let carretera=0; let myFont; function preload() { mustang = loadModel(\u0026#39;/showcase/sketches/taller2/assets/ford_mustan_gt1967.obj\u0026#39;); img = loadImage(\u0026#39;/showcase/sketches/taller2/assets/pexels-life-of-pix-8892.jpg\u0026#39;); } function setup() { createCanvas(710, 400, WEBGL); cam= createCamera(); cam.move(0,-100,0) } function draw() { background(250); translate(0, 0, 0); normalMaterial(); push(); translate(k, 0, j); rotateY(i-3.017); scale(50); rotateX(9.5); //texture(img); model(mustang); //box(10); pop(); translate(250, 0, 0); print(\u0026#39;The value of x is \u0026#39; +k); if (keyIsPressed === true\u0026amp;\u0026amp;keyCode === RIGHT_ARROW) { if(i\u0026gt;-0.5) i=i-0.1 else i=-0.5 if(k\u0026lt;200) k=k+5 else{ k=200 i=0 } } if (keyIsPressed === true\u0026amp;\u0026amp;keyCode === LEFT_ARROW) { if(i\u0026lt;0.5) i=i+0.1 else i=0.5 k=k-5 if(k\u0026gt;-200) k=k-5 else{ k=-200 i=0 } } j=j-10 cam.move(0,0,-10); push(); rotateX(HALF_PI); texture(img); plane(800,12000); //translate(0,carretera); //carretera=carretera-1200*8 pop(); } {{\u0026lt; /p5-global-iframe \u0026gt;}} Referencias # Movimiento mientras se presiona una tecla Modelo mustan Textura caretera "},{"id":4,"href":"/showcase/docs/shortcodes/taller2/","title":"Taller2","section":"Shortcodes","content":" Taller 1 # p5 helps add p5 sketches into your book. There are two types of p5 shortcodes according to the html element used to embed them.\nTypes # 3 Dapp Aplicación en 3d 1 # El juego consiste en llevar la bola hasta el final de la pista, al finalizar nos mostrará el tiempo que nos demoramos en llegar a la meta, para movernos hacia adelante, hacia la izquierda y hacia la derecha oprimimos las teclas w,a y d. Al iniciar habrán 3 barras, la primera indica el largo de la pista, la segunda el alto de los obstáculos y la tercera la distancia entre estos. "},{"id":5,"href":"/showcase/docs/shortcodes/taller3/","title":"Taller3","section":"Shortcodes","content":" Taller 3 # Shaders\nTypes # Taller3 Geometría no euclidiana # Se denomina geometría no euclidiana a un sistema de geometría que no cumple con los postulados establecidas por Euclides: dado dos puntos se puede trazar una sola recta que los une cualquier segmento puede prolongarse de manera continua en cualquier sentido se puede trazar una circunferencia con centro de cualquier punto y de cualquier radio todos los ángulos rectos son congruentes por un punto exterior a una recta se puede trazar una paralela (surge la geometría no euclidiana, hiperbólica-lobachevsky: existen varias paralelas, eliptica-riemann: no pasa una recta paralela. "},{"id":6,"href":"/showcase/docs/shortcodes/taller3/Taller3/","title":"Taller3","section":"Taller3","content":" Geometría no euclidiana # Se denomina geometría no euclidiana a un sistema de geometría que no cumple con los postulados establecidas por Euclides:\ndado dos puntos se puede trazar una sola recta que los une cualquier segmento puede prolongarse de manera continua en cualquier sentido se puede trazar una circunferencia con centro de cualquier punto y de cualquier radio todos los ángulos rectos son congruentes por un punto exterior a una recta se puede trazar una paralela (surge la geometría no euclidiana, hiperbólica-lobachevsky: existen varias paralelas, eliptica-riemann: no pasa una recta paralela. y en este trabajo lo podemos ver al crear un enlace entre dos espacios virtuales compartiendo un mismo punto de vista.\nPara esto se crean 5 sesiones en p5 graphics, en las cuales se cargan los modelos 3D y una cámara que comparte punto de vista en las 5 sesiones, de estas sesiones lo que observa la cámara va a utilizarse como textura, estas se envían como texturas al fragment shader para posteriormente mapearse sobre una de las caras del cubo.\nProcedural texturing # Una textura procedimental, es una textura que se crea a partir de un algoritmo, generando en tiempo real mediante este, en vez de ya estar almacenada directamente. En este ejercicio la meta es crear una textura que se modifique en tiempo de ejecución siguiendo un algoritmo, para este ejercicio decidimos utilizar la ecuación del amor. Para la solución de este ejercicio se adaptó un código del libro book of shaders, en el que se enseña las funciones que se pueden usar en un shader y cómo podemos hacer para crear movimiento con las uniforms y las varyings.\n\\[x^{2}\u0026#43;\\left ( y- \\sqrt[3]{x^{2}} \\right )^{2}= 1\\] código software js let easycam; let edge = 160; let teapot; let teapotTex; let bunny; let bunnyTex; let tails; let tailsTex; let crash; let crashTex; let dio; let dioTex; let rex; let rexTex; let texShader; let miShader; let pg; let truchetShader; function preload() { truchetShader = readShader(\u0026#39;/showcase/sketches/taller3/shader2.frag\u0026#39;, { matrices: Tree.NONE, varyings: Tree.NONE }); // no varyings need to be emitted from the vertex shader texShader = readShader(\u0026#39;/showcase/sketches/taller3/fragmentShader.frag\u0026#39;, { varyings: Tree.NONE }); miShader = readShader(\u0026#39;/showcase/sketches/taller3/shader2.frag\u0026#39;, { varyings: Tree.NONE }); teapot = loadModel(\u0026#39;/showcase/sketches/taller3/teapot.obj\u0026#39;, true); bunny = loadModel(\u0026#39;/showcase/sketches/taller3/bunny.obj\u0026#39;, true); tails = loadModel(\u0026#39;/showcase/sketches/taller3/Tails.obj\u0026#39;, true); crash = loadModel(\u0026#39;/showcase/sketches/taller3/crash.obj\u0026#39;, true); dio = loadModel(\u0026#39;/showcase/sketches/taller3/dio.obj\u0026#39;, true); rex = loadModel(\u0026#39;/showcase/sketches/taller3/rex.obj\u0026#39;, true); } function setup() { createCanvas(800, 600, WEBGL); // no need to normalize the texture // textureMode(NORMAL); shader(texShader); // resolution will be used to sample the offscreen textures emitResolution(texShader); easycam = createEasyCam(); teapotTex = createGraphics(width, height, WEBGL); bunnyTex = createGraphics(width, height, WEBGL); tailsTex = createGraphics(width, height, WEBGL); crashTex = createGraphics(width, height, WEBGL); dioTex = createGraphics(width, height, WEBGL); rexTex = createGraphics(width, height, WEBGL); pg = createGraphics(width, height, WEBGL); textureMode(NORMAL); pg.noStroke(); pg.textureMode(NORMAL); pg.background(255); pg.reset(); pg.push(); truchetShader.setUniform(\u0026#39;u_mouse\u0026#39;, mouseX+0.0); pg.shader(truchetShader); // emitResolution, see: // https://github.com/VisualComputing/p5.treegl#macros pg.emitResolution(truchetShader); // https://p5js.org/reference/#/p5.Shader/setUniform truchetShader.setUniform(\u0026#39;u_time\u0026#39;, frameCount); truchetShader.setUniform(\u0026#39;u_mouse\u0026#39;, mouseX+0.0); // pg clip-space quad (i.e., both x and y vertex coordinates ∈ [-1..1]) pg.quad(-1, -1, 1, -1, 1, 1, -1, 1); } function draw() { // 1. compute current main canvas camera params let position = treeLocation(); let center = p5.Vector.add(position, treeDisplacement()); let up = treeDisplacement(Tree.j); // in case the current camera projection params are needed check: // https://github.com/VisualComputing/p5.treegl#frustum-queries // 2. offscreen rendering // bunny graphics bunnyTex.background(200); bunnyTex.reset(); bunnyTex.camera(position.x, position.y, position.z, center.x, center.y, center.z, up.x, up.y, up.z); bunnyTex.push(); bunnyTex.noStroke(); bunnyTex.fill(\u0026#39;red\u0026#39;); // most models use positive y-coordinates bunnyTex.scale(1, -1); bunnyTex.scale(0.8);// only bunny bunnyTex.model(bunny); bunnyTex.pop(); // teapot graphics teapotTex.background(200); teapotTex.reset(); teapotTex.camera(position.x, position.y, position.z, center.x, center.y, center.z, up.x, up.y, up.z); teapotTex.push(); teapotTex.noStroke(); teapotTex.fill(\u0026#39;blue\u0026#39;); teapotTex.scale(1, -1); teapotTex.model(teapot); teapotTex.pop(); tailsTex.background(200); tailsTex.reset(); tailsTex.camera(position.x, position.y, position.z, center.x, center.y, center.z, up.x, up.y, up.z); tailsTex.push(); tailsTex.noStroke(); tailsTex.fill(\u0026#39;orange\u0026#39;); // most models use positive y-coordinates tailsTex.scale(1, -1); tailsTex.model(tails); tailsTex.pop() crashTex.background(200); crashTex.reset(); crashTex.camera(position.x, position.y, position.z, center.x, center.y, center.z, up.x, up.y, up.z); crashTex.push(); crashTex.noStroke(); crashTex.fill(\u0026#39;orange\u0026#39;); // most models use positive y-coordinates crashTex.scale(1, -1); crashTex.model(crash); crashTex.pop() dioTex.background(225); dioTex.reset(); dioTex.camera(position.x, position.y, position.z, center.x, center.y, center.z, up.x, up.y, up.z); dioTex.push(); dioTex.noStroke(); dioTex.fill(\u0026#39;yellow\u0026#39;); // most models use positive y-coordinates dioTex.scale(1, -1); dioTex.model(dio); dioTex.pop() rexTex.background(225); rexTex.reset(); rexTex.camera(position.x, position.y, position.z, center.x, center.y, center.z, up.x, up.y, up.z); rexTex.push(); rexTex.noStroke(); rexTex.fill(\u0026#39;gray\u0026#39;); // most models use positive y-coordinates rexTex.scale(1, -1); rexTex.model(rex); rexTex.pop() // 3. main canvas background(0); push(); // front (+z) stroke(\u0026#39;purple\u0026#39;); strokeWeight(5); texShader.setUniform(\u0026#39;texture\u0026#39;, bunnyTex); beginShape(); vertex(+edge, +edge, -edge); vertex(-edge, +edge, -edge); vertex(-edge, +edge, +edge); vertex(+edge, +edge, +edge); endShape(CLOSE); texShader.setUniform(\u0026#39;texture\u0026#39;, teapotTex); beginShape(); vertex(-edge, -edge, +edge); vertex(+edge, -edge, +edge); vertex(+edge, -edge, -edge); vertex(-edge, -edge, -edge); endShape(CLOSE); texShader.setUniform(\u0026#39;texture\u0026#39;, dioTex); beginShape(); vertex(-edge, -edge, +edge); vertex(+edge, -edge, +edge); vertex(+edge, +edge, +edge); vertex(-edge, +edge, +edge); endShape(CLOSE); push(); shader(truchetShader); truchetShader.setUniform(\u0026#39;u_resolution\u0026#39;, [width, height]); truchetShader.setUniform(\u0026#39;u_time\u0026#39;, frameCount/100+0.0); pg.quad(-1, -1, 1, -1, 1, 1, -1, 1); texture(pg); translate(0,0,-edge); square(-edge, -edge, edge+edge); pop(); texShader.setUniform(\u0026#39;texture\u0026#39;, crashTex); beginShape(); vertex(+edge, -edge, +edge); vertex(+edge, -edge, -edge); vertex(+edge, +edge, -edge); vertex(+edge, +edge, +edge); endShape(CLOSE); texShader.setUniform(\u0026#39;texture\u0026#39;, tailsTex); beginShape(); vertex(-edge, +edge, -edge); vertex(-edge, +edge, +edge); vertex(-edge, -edge, +edge); vertex(-edge, -edge, -edge); endShape(CLOSE); pop(); pop(); } código fragment shader Geometría no euclidiana precision mediump float; uniform sampler2D texture; uniform vec2 u_resolution; void main() { vec2 st1 = gl_FragCoord.xy / u_resolution; gl_FragColor = texture2D(texture, vec2(st1.x,(1.0-st1.y))); } código fragment shader procedural texturing // Author:Kevin Fabio Ramos López #ifdef GL_ES precision mediump float; #endif #define PI 3.14159265359 uniform vec2 u_resolution; uniform vec2 u_mouse; uniform float u_time; uniform sampler2D tex; float plot(vec2 st, float pct){ return smoothstep( pct-0.02, pct+0.02, st.y) - smoothstep( pct+.02, pct+0.02, st.y); }//tomado de https://thebookofshaders.com/ void main() { float a=2.75; float time= 9.0; vec2 st = gl_FragCoord.xy/u_resolution; float x=st.x*(a+sin(u_time*time))-2.2-(-(cos(u_time*time))); // Smooth interpolation between 0.1 and 0.9 float y = 0.89+(sqrt(-x*x+1.0)+pow(x*x, 1.0/ 3.0))/(a+sin(u_time*time)); float z = 0.9+(-sqrt(-x*x+1.0)+pow(x*x, 1.0/ 3.0))/(a+sin(u_time*time)); vec3 color = vec3(y); float pct = plot(st,y); float pct2 = plot(st,z); color = +pct*vec3(0.0,1.0,1.0)+pct2*vec3(0.0,1.0,1.0); gl_FragColor = vec4(.8,.8,.8,1.0)-vec4(color,abs(sin(u_time*time))); } Pixelator # para mover el vehículo hacia la izquierda oprimimos la tecla izquierda y para moverlo a la derecha la derecha, el vehículo se mueve automáticamente hacia adelante. Referencias # Movimiento mientras se presiona una tecla Modelo mustan Textura caretera Footer "}]