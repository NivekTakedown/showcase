[{"id":0,"href":"/showcase/docs/shortcodes/taller1/","title":"Taller1","section":"Shortcodes","content":" Taller 1 # p5 helps add p5 sketches into your book. There are two types of p5 shortcodes according to the html element used to embed them.\nTypes # Ilusion Optica Ilusiones ópticas # Una ilusión óptica es una ilusión que afecta a nuestro sistema visual haciendo que veamos la realidad de una manera distorsionada. Percepción de movimiento y profundidad # Estas ilusiones ópticas se basan en nuestra habilidad para reconocer el mundo, utiliza nuestra memoria visual para hacernos ver algo con ṕrofundidad, aun si lo que estamos viendo está solo en 2 dimensiones. O con movimiento, haciendo que algunos objetos se muevan más rápido que otros, tanto las animaciones como los videojuegos hacen uso de estas ilusiones. Masking Masking # Un kernel es una mask que se usa para aplicar filtros a una imagen. Estas máscaras tienen forma de matriz cuadrada, por lo que también se denominan matrices de convolución. Consideremos la matriz A, que representa la matriz que contiene los valores de gris de todos los píxeles de la imagen original, y la matriz B que representa la matriz kernel. Ahora superpongamos la matriz A con la matriz B, de modo que el centro de la matriz B corresponda al píxel de la matriz A que se procesará. "},{"id":1,"href":"/showcase/docs/shortcodes/taller1/ilusion_optica/","title":"Ilusion Optica","section":"Taller1","content":" Ilusiones ópticas # Una ilusión óptica es una ilusión que afecta a nuestro sistema visual haciendo que veamos la realidad de una manera distorsionada. Percepción de movimiento y profundidad # Estas ilusiones ópticas se basan en nuestra habilidad para reconocer el mundo, utiliza nuestra memoria visual para hacernos ver algo con ṕrofundidad, aun si lo que estamos viendo está solo en 2 dimensiones. O con movimiento, haciendo que algunos objetos se muevan más rápido que otros, tanto las animaciones como los videojuegos hacen uso de estas ilusiones. Look at this reference\nMoving picture # código moving picture {{\u0026lt; p5-global-iframe id=\u0026#34;breath\u0026#34; width=\u0026#34;625\u0026#34; height=\u0026#34;625\u0026#34; \u0026gt;}} // Coded as `global mode` of [this](https://github.com/VisualComputing/Cognitive/blob/gh-pages/sketches/rotateSquare.js) let x,y,c1,c2,c3,c4,c5,c6,c7,c8,c9,c10,c11,c12,c13,c14,c15,c16,c17,c18,c19, c20,c21,c22,c23,c24,c25,c26,c27,c28,c29,c30,c31,c32,c33,c34,c35; function setup(){ createCanvas(720,400); strokeWeight(2); x = width/2; y = height/2; c1=16*1;c2=16*2;c3=16*3;c4=16*4;c5=16*5;c6=16*6;c7=16*7;c8=16*8;c9=16*9; c10=16*10;c11=16*11;c12=16*12;c13=16*13;c14=16*14;c15=16*15;c16=16*16; c17=16*17;c18=16*18;c19=16*19;c20=16*20;c21=16*21;c22=16*22;c23=16*23; c24=16*24;c25=16*25;c26=16*26;c27=16*27;c28=16*28;c29=16*29;c30=16*30; c31=16*31;c32=16*32;c33=16*33;c34=16*34;c35=16*35; } function draw(){ background(\u0026#34;white\u0026#34;); //line(0,y,width,y); //line(x,0,x,height); fill(\u0026#39;red\u0026#39;); stroke(\u0026#39;red\u0026#39;); circle(x,y,5); stroke(\u0026#39;black\u0026#39;); cuadro(x,y,c1);cuadro(x,y,c2);cuadro(x,y,c3);cuadro(x,y,c4); cuadro(x,y,c5);cuadro(x,y,c6);cuadro(x,y,c7);cuadro(x,y,c8); cuadro(x,y,c9);cuadro(x,y,c10);cuadro(x,y,c11);cuadro(x,y,c12); cuadro(x,y,c13);cuadro(x,y,c14);cuadro(x,y,c15);cuadro(x,y,c16); cuadro(x,y,c17);cuadro(x,y,c18);cuadro(x,y,c19);cuadro(x,y,c20); cuadro(x,y,c21);cuadro(x,y,c22);cuadro(x,y,c23);cuadro(x,y,c24); cuadro(x,y,c25);cuadro(x,y,c26);cuadro(x,y,c27);cuadro(x,y,c28); cuadro(x,y,c29);cuadro(x,y,c30);cuadro(x,y,c31);cuadro(x,y,c32); cuadro(x,y,c33);cuadro(x,y,c34);cuadro(x,y,c35); c1+=16;c2+=16;c3+=16;c4+=16;c5+=16;c6+=16;c7+=16;c8+=16;c9+=16;c10+=16; c11+=16;c12+=16;c13+=16;c14+=16;c15+=16;c16+=16;c17+=16;c18+=16;c19+=16; c20+=16;c21+=16;c22+=16;c23+=16;c24+=16;c25+=16;c26+=16;c27+=16;c28+=16; c29+=16;c30+=16;c31+=16;c32+=16;c33+=16;c34+=16;c35+=16; if(c35 \u0026gt; 560){c35 = 0;}if(c34 \u0026gt; 560){c34 = 0;}if(c33 \u0026gt; 560){c33 = 0;} if(c32 \u0026gt; 560){c32 = 0;}if(c31 \u0026gt; 560){c31 = 0;}if(c30 \u0026gt; 560){c30 = 0;} if(c29 \u0026gt; 560){c29 = 0;}if(c28 \u0026gt; 560){c28 = 0;}if(c27 \u0026gt; 560){c27 = 0;} if(c26 \u0026gt; 560){c26 = 0;}if(c25 \u0026gt; 560){c25 = 0;}if(c24 \u0026gt; 560){c24 = 0;} if(c23 \u0026gt; 560){c23 = 0;}if(c22 \u0026gt; 560){c22 = 0;}if(c21 \u0026gt; 560){c21 = 0;} if(c20 \u0026gt; 560){c20 = 0;}if(c19 \u0026gt; 560){c19 = 0;}if(c18 \u0026gt; 560){c18 = 0;} if(c17 \u0026gt; 560){c17 = 0;}if(c16 \u0026gt; 560){c16 = 0;}if(c15 \u0026gt; 560){c15 = 0;} if(c14 \u0026gt; 560){c14 = 0;}if(c13 \u0026gt; 560){c13 = 0;}if(c12 \u0026gt; 560){c12 = 0;} if(c11 \u0026gt; 560){c11 = 0;}if(c10 \u0026gt; 560){c10 = 0;}if(c9 \u0026gt; 560){c9 = 0;} if(c8 \u0026gt; 560){c8 = 0;}if(c7 \u0026gt; 560){c7 = 0;}if(c6 \u0026gt; 560){c6 = 0;} if(c5 \u0026gt; 560){c5 = 0;}if(c4 \u0026gt; 560){c4 = 0;}if(c3 \u0026gt; 560){c3 = 0;} if(c2 \u0026gt; 560){c2 = 0;}if(c1 \u0026gt; 560){c1 = 0;} } function cuadro(x,y,ct){ line(x-ct,y,x,y-ct); line(x,y-ct,x+ct,y); line(x-ct,y,x,y+ct); line(x,y+ct,x+ct,y); } {{\u0026lt; /p5-global-iframe \u0026gt;}} Estrella # En este lugar se puede encontrar la ilusión óptica original: this reference\ncódigo estrella {{\u0026lt; p5-global-iframe id=\u0026#34;breath\u0026#34; width=\u0026#34;625\u0026#34; height=\u0026#34;625\u0026#34; \u0026gt;}} // Coded as `global mode` of [this](https://github.com/VisualComputing/Cognitive/blob/gh-pages/sketches/rotateSquare.js) let h; let w; let perc1; let perc2; let perc3; function setup() { createCanvas(400, 400); h=float(0.9); w=float(width/2); perc1=0.05; perc2=0.0125; perc3=0.1; } function draw() { background(220); let num = 26; let num1 = 1; while (num \u0026gt; 0) { if (num % 2==0) { fill(0,0,0); } else { fill(255,255,255) } num = num - 1; square(w*0.0125+w+perc1*w*num1/30,w*perc2+w+perc1*w*num1/30,w*h-num1); square(-w*perc2+(1-h)*w+perc3*w*num1/30,+w*perc2+w+perc1*w*num1/30,w*h-num1); square(w*perc2+w+perc1*w*num1/30,+w*0.085+perc3*w*num1/30,w*h-num1); square(-w*perc2+(1-h)*w+perc3*w*num1/30,+w*0.085+perc3*w*num1/30,w*h-num1); num1 = num1+ 7; } } {{\u0026lt; /p5-global-iframe \u0026gt;}} Estrella ajustable # En este lugar se puede encontrar la ilusión óptica original: this reference\ncódigo estrella {{\u0026lt; p5-global-iframe id=\u0026#34;breath\u0026#34; width=\u0026#34;625\u0026#34; height=\u0026#34;625\u0026#34; \u0026gt;}} // Coded as `global mode` of [this](https://github.com/VisualComputing/Cognitive/blob/gh-pages/sketches/rotateSquare.js) let h; let w; let perc1; let perc2; let perc3; let slider; let slider1; let slider2; function setup() { createCanvas(400, 400); h=float(0.9); w=float(width/2); slider=createSlider(0, 0.15, 0.03, 0.01); slider2=createSlider(0, 0.15, 0.12, 0.01); } function draw() { background(255); perc1 = slider.value(); perc2=0.0125; perc3=slider2.value(); let num = 26; let num1 = 1; while (num \u0026gt; 0) { if (num % 2==0) { fill(0,0,0); } else { fill(255,255,255) } num = num - 1; square(w*0.0125+w+perc1*w*num1/30,w*perc2+w+perc1*w*num1/30,w*h-num1); square(-w*perc2+(1-h)*w+perc3*w*num1/30,+w*perc2+w+perc1*w*num1/30,w*h-num1); square(w*perc2+w+perc1*w*num1/30,+w*0.085+perc3*w*num1/30,w*h-num1); square(-w*perc2+(1-h)*w+perc3*w*num1/30,+w*0.085+perc3*w*num1/30,w*h-num1); num1 = num1+ 7; } } {{\u0026lt; /p5-global-iframe \u0026gt;}} "},{"id":2,"href":"/showcase/docs/shortcodes/taller1/Masking/","title":"Masking","section":"Taller1","content":" Masking # Un kernel es una mask que se usa para aplicar filtros a una imagen. Estas máscaras tienen forma de matriz cuadrada, por lo que también se denominan matrices de convolución.\nConsideremos la matriz A, que representa la matriz que contiene los valores de gris de todos los píxeles de la imagen original, y la matriz B que representa la matriz kernel. Ahora superpongamos la matriz A con la matriz B, de modo que el centro de la matriz B corresponda al píxel de la matriz A que se procesará.\nEl valor de la imagen objetivo (matriz C) se calcula como la suma de todos los elementos de la matriz resultante del producto de Hadamard entre las matrices A y B.\nRecordamos que el producto de Hadamard es una operación binaria que toma dos matrices de la misma dimensione y produce otra matriz de igual dimensión, donde cada elemento i , j es el producto de los elementos i , j de las dos matrices originales\nLook at this reference for an explanation and further parameterization of the illusion.\ncódigo moving picture {{\u0026lt; p5-global-iframe id=\u0026#34;breath\u0026#34; width=\u0026#34;800\u0026#34; height=\u0026#34;600\u0026#34; \u0026gt;}} // Coded as `global mode` of [this](https://github.com/VisualComputing/Cognitive/blob/gh-pages/sketches/rotateSquare.js) let tab; //menu de seleccion let selec; let img; let c1=0;let c2=0;let c3=0;let c4=0; function setup() { var canvas = createCanvas(800,600); background(209); canvas.drop(gotFile); tab= createSelect(); tab.position(10, 10); tab.option(\u0026#39;Masking\u0026#39;); tab.option(\u0026#39;-gris\u0026#39;); tab.option(\u0026#39;-invert\u0026#39;); tab.option(\u0026#39;-threshold\u0026#39;); tab.option(\u0026#39;-blur\u0026#39;); tab.option(\u0026#39;-erode\u0026#39;); tab.option(\u0026#39;-dilate\u0026#39;); tab.option(\u0026#39;-sin filtro\u0026#39;); tab.changed(pickEvent); } function gotFile(file) { img = createImg(file.data); img.hide(); image(img,0,0,800,600); } function pickEvent() { selec = tab.value(); if (selec === \u0026#39;-gris\u0026#39;) { selec = 1; } else if (selec === \u0026#39;-invert\u0026#39;) { selec = 2; } else if (selec === \u0026#39;-threshold\u0026#39;) { selec = 3; } else if (selec === \u0026#39;-blur\u0026#39;) { selec = 4; } else if (selec === \u0026#39;-erode\u0026#39;) { selec = 5; } else if (selec === \u0026#39;-dilate\u0026#39;) { selec = 6; } else if (selec === \u0026#39;-sin filtro\u0026#39;) { selec = 0; } } function canva(){ createCanvas(800,600); background(209); image(img,0,0,800,600); } function draw(){ if (selec == 1){ c1=0;c2=0;c3=0;c4=0; canva(); filter(GRAY); //escala de grises } else if (selec == 2){ c1=0;c2=0;c3=0; c4 = c4+1; if (c4 == 1){ canva(); filter(INVERT); } } else if (selec == 3){ c1=0;c2=0;c3=0;c4=0; canva(); filter(THRESHOLD); //píxeles en blanco y negro umbral } else if (selec == 4){ c2=0;c3=0;c4=0; c1 = c1+1; if (c1 == 1){ canva(); filter(BLUR,3); //desenfoque } } else if (selec == 5){ c1=0;c3=0;c4=0; c2 = c2+1; if (c2 == 1){ canva(); filter(ERODE) //reduce las areas claras } } else if (selec == 6){ c2=0;c1=0;c4=0; c3 = c3+1; if (c3 == 1){ canva(); filter(DILATE ); //aumenta las areas claras } } else if (selec == 0){ c1=0;c2=0;c3=0;c4=0; canva(); } } {{\u0026lt; /p5-global-iframe \u0026gt;}} histograma de imagen # Un histograma de imagen, es un histograma que actúa como una representación gráfica de la distribución de tonos en la imagen, nos dice la influencia de cada uno de los colores a lo largo de toda la imagen. Para mostrar el histograma seleccionamos la imagen con el botón browse, mostramos la imagen con el botón izquierda y mostramos el histograma con el botón derecha.\ncódigo histograma {{\u0026lt; p5-global-iframe id=\u0026#34;breath\u0026#34; width=\u0026#34;800\u0026#34; height=\u0026#34;600\u0026#34; \u0026gt;}} let input; let img; let histogramR ; let histogramG ; let histogramB ; function setup() { createCanvas(800, 600); input = createFileInput(handleFile); input.position(0, 0); histogramR= []; histogramG= []; histogramB= []; for(let i = 0; i \u0026lt; 256; i++){ histogramR[i] = 0; histogramG[i] = 0; histogramB[i] = 0; } } function showHistogram(){ let j=0; for(let i = 0; i \u0026lt; 510; i++){ if(i%2==0){ fill(color(\u0026#34;red\u0026#34;)); stroke(color(\u0026#34;red\u0026#34;)); line(i,600,i,600-histogramR[j]); fill(color(\u0026#34;green\u0026#34;)); stroke(color(\u0026#34;green\u0026#34;)); line(i,600,i,600-histogramG[j]); fill(color(\u0026#34;blue\u0026#34;)); stroke(color(\u0026#34;blue\u0026#34;)); line(i,600,i,600-histogramB[j]); j++; } } } function keyPressed() { if (keyCode === LEFT_ARROW) { image(img, 0, 0, 800, 600); } else if (keyCode === RIGHT_ARROW) { Histogram(); showHistogram(); } } function handleFile(file) { print(file); if (file.type === \u0026#39;image\u0026#39;) { img = createImg(file.data, \u0026#39;\u0026#39;); img.hide(); } else { img = null; } } function Histogram(){ console.log(\u0026#34;hist\u0026#34;); for(let i = 0; i \u0026lt; 800; i=i+4){ for(let j = 0; j \u0026lt; 600; j=j+4){ let c=get(i, j); histogramR[c[0]] =histogramR[c[0]]+1; histogramG[c[1]] =histogramG[c[1]]+1; histogramB[c[2]] =histogramB[c[2]]+1; console.log(histogramR[c]); } } background(255); } {{\u0026lt; /p5-global-iframe \u0026gt;}} HSV y HSL # HSL y HSV, son representaciones alternativas del modelo de color RGB. La representación HSL modela la forma en que las diferentes pinturas se mezclan para crear color en el mundo real, con la dimensión de luminosidad que se asemeja a las cantidades variables de pintura negra o blanca en la mezcla. Mientras tanto, la representación de HSV modela cómo aparecen los colores bajo la luz. La diferencia entre HSL y HSV es que un color con máxima luminosidad en HSL es blanco puro, pero un color con máximo valor/brillo en HSV es similar a hacer brillar una luz blanca sobre un objeto de color. código histograma {{\u0026lt; p5-global-iframe id=\u0026#34;breath\u0026#34; width=\u0026#34;800\u0026#34; height=\u0026#34;600\u0026#34; \u0026gt;}} var masterColor = {r: 0,g: 0,b: 0,h: 0,s: 0,v: 0,hs: 0,ss:0 ,l:0}; //toma de datos rgb let rSlider, gSlider, bSlider; let inpR, inpG, inpB; //variables hsb var hType = 0; var max = {colour: \u0026#34;-\u0026#34;,value: 0}; var min = {colour: \u0026#34;-\u0026#34;,value: 0}; function setup() { //background(50); //no funciona (╥_╥) createCanvas(800, 600); setUpRGBpicker(0, 0); } function draw() { drawRGBpicker(0, 0); drawHSVpicker(200, 0); drawHSLpicker(400,0); calHSV(); } function setUpRGBpicker(x, y) { rSlider = createSlider(0, 255, random(255)); rSlider.position(x + 15, y + 200); gSlider = createSlider(0, 255, random(255)); gSlider.position(x + 15, y + 230); bSlider = createSlider(0, 255, random(255)); bSlider.position(x + 15, y + 260); inpR = createInput(rSlider.value(), \u0026#34;number\u0026#34;); inpR.position(x + 150, y + 200); inpR.size(40, 20); inpG = createInput(gSlider.value(), \u0026#34;number\u0026#34;); inpG.position(x + 150, y + 230); inpG.size(40, 20); inpB = createInput(bSlider.value(), \u0026#34;number\u0026#34;); inpB.position(x + 150, y + 260); inpB.size(40, 20); rSlider.input(valueUpdate.bind(null, inpR, rSlider)); inpR.input(valueUpdate.bind(null, rSlider, inpR)); gSlider.input(valueUpdate.bind(null, inpG, gSlider)); inpG.input(valueUpdate.bind(null, gSlider, inpG)); bSlider.input(valueUpdate.bind(null, inpB, bSlider)); inpB.input(valueUpdate.bind(null, bSlider, inpB)); } function drawRGBpicker(x, y) { colorMode(RGB, 255); noStroke(); fill(rSlider.value(), gSlider.value(), bSlider.value()); rect(x + 20, y + 20, 160, 160); //color de las filas fill(255, 0, 0); rect(rSlider.x, rSlider.y, rSlider.width + 5, rSlider.height + 5); fill(0, 255, 0); rect(gSlider.x, gSlider.y, gSlider.width + 5, gSlider.height + 5); fill(0, 0, 255); rect(bSlider.x, bSlider.y, bSlider.width + 5, bSlider.height + 5); // masterColor.r = map(rSlider.value(), 0, 255, 0, 1); masterColor.g = map(gSlider.value(), 0, 255, 0, 1); masterColor.b = map(bSlider.value(), 0, 255, 0, 1); } function drawHSVpicker(x, y) { colorMode(HSB, 100); map(masterColor.s,0,1,0,100) fill(map(masterColor.h,0,1,0,360), map(masterColor.s,0,1,0,100), map(masterColor.v,0,1,0,100)); rect(x + 20, y + 20, 160, 160); } function drawHSLpicker(x,y){ //colorMode(HSL, 100); let c = color(masterColor.r, masterColor.g, masterColor.b); masterColor.hs = floor( hue(c) ); masterColor.ss = saturation(c); masterColor.l = lightness(c); console.log(masterColor); fill( `hsl(${ map(masterColor.hs,0,1,0,360) }, ${map(masterColor.ss,0,1,0,100) }%, ${map(masterColor.l,0,1,0,100)}%)` ); rect(x+20,y+20,160,160); } function calHSV() { masterColor.s = (maxRGB() - minRGB()) / maxRGB(); if (isNaN(masterColor.s)) { masterColor.s = 0; } masterColor.v = maxRGB(); var dr = (maxRGB() - masterColor.r) / maxRGB() - minRGB(); var dg = (maxRGB() - masterColor.g) / maxRGB() - minRGB(); var db = (maxRGB() - masterColor.b) / maxRGB() - minRGB(); if (masterColor.s == 0) { masterColor.h = 0; hType = 0; } else if (masterColor.r == maxRGB() \u0026amp;\u0026amp; masterColor.g == minRGB()) { masterColor.h = 5 + db; hType = 1; } else if (masterColor.r == maxRGB() \u0026amp;\u0026amp; masterColor.g != minRGB()) { masterColor.h = 1 - dg; hType = 2; } else if (masterColor.g == maxRGB() \u0026amp;\u0026amp; masterColor.b == minRGB()) { masterColor.h = dr + 1; hType = 3; } else if (masterColor.g == maxRGB() \u0026amp;\u0026amp; masterColor.b != minRGB()) { masterColor.h = 3 - db; hType = 4; } else if (masterColor.r == maxRGB()) { masterColor.h = 3 + dg; hType = 5; } else { masterColor.h = 5 - dr; hType = 6; } masterColor.h = masterColor.h * 60; } function valueUpdate(a, b, c) { a.value(b.value()); } function maxRGB() { var r = masterColor.r; var g = masterColor.g; var b = masterColor.b; var temp = Math.max(Math.max(r, g), b); if (temp == r) { max.colour = \u0026#34;r\u0026#34;; max.value = r; } else if (temp == g) { max.colour = \u0026#34;g\u0026#34;; max.value = g; } else if (temp == b) { max.colour = \u0026#34;b\u0026#34;; max.value = b; } return temp; } function minRGB() { var r = masterColor.r; var g = masterColor.g; var b = masterColor.b; var temp = Math.min(Math.min(r, g), b); if (temp == r) { min.colour = \u0026#34;r\u0026#34;; min.value = r; } else if (temp == g) { min.colour = \u0026#34;g\u0026#34;; min.value = g; } else if (temp == b) { min.colour = \u0026#34;b\u0026#34;; min.value = b; } return temp; } {{\u0026lt; /p5-global-iframe \u0026gt;}} Referencias # Making Filters Using p5.js! Kernel convolution Histograma filter histograma HCL Y HSL HCL Y HSL HCL Y HSL HCL Y HSL "}]