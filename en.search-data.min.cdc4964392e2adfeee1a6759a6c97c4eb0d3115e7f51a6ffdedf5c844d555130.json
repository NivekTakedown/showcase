[{"id":0,"href":"/showcase/docs/shortcodes/taller1/","title":"Taller1","section":"Shortcodes","content":" Taller 1 # p5 helps add p5 sketches into your book. There are two types of p5 shortcodes according to the html element used to embed them.\nTypes # Ilusion Optica Ilusiones ópticas # Una ilusión óptica es una ilusión que afecta a nuestro sistema visual haciendo que veamos la realidad de una manera distorsionada. Percepción de movimiento y profundidad # Estas ilusiones ópticas se basan en nuestra habilidad para reconocer el mundo, utiliza nuestra memoria visual para hacernos ver algo con ṕrofundidad, aun si lo que estamos viendo está solo en 2 dimensiones. O con movimiento, haciendo que algunos objetos se muevan más rápido que otros, tanto las animaciones como los videojuegos hacen uso de estas ilusiones. Masking Masking # Un kernel es una mask que se usa para aplicar filtros a una imagen. Estas máscaras tienen forma de matriz cuadrada, por lo que también se denominan matrices de convolución. Consideremos la matriz A, que representa la matriz que contiene los valores de gris de todos los píxeles de la imagen original, y la matriz B que representa la matriz kernel. Ahora superpongamos la matriz A con la matriz B, de modo que el centro de la matriz B corresponda al píxel de la matriz A que se procesará. "},{"id":1,"href":"/showcase/docs/shortcodes/taller1/ilusion_optica/","title":"Ilusion Optica","section":"Taller1","content":" Ilusiones ópticas # Una ilusión óptica es una ilusión que afecta a nuestro sistema visual haciendo que veamos la realidad de una manera distorsionada. Percepción de movimiento y profundidad # Estas ilusiones ópticas se basan en nuestra habilidad para reconocer el mundo, utiliza nuestra memoria visual para hacernos ver algo con ṕrofundidad, aun si lo que estamos viendo está solo en 2 dimensiones. O con movimiento, haciendo que algunos objetos se muevan más rápido que otros, tanto las animaciones como los videojuegos hacen uso de estas ilusiones. Look at this reference\nMoving picture # código moving picture {{\u0026lt; p5-global-iframe id=\u0026#34;breath\u0026#34; width=\u0026#34;625\u0026#34; height=\u0026#34;625\u0026#34; \u0026gt;}} // Coded as `global mode` of [this](https://github.com/VisualComputing/Cognitive/blob/gh-pages/sketches/rotateSquare.js) let x,y,c1,c2,c3,c4,c5,c6,c7,c8,c9,c10,c11,c12,c13,c14,c15,c16,c17,c18,c19, c20,c21,c22,c23,c24,c25,c26,c27,c28,c29,c30,c31,c32,c33,c34,c35; function setup(){ createCanvas(720,400); strokeWeight(2); x = width/2; y = height/2; c1=16*1;c2=16*2;c3=16*3;c4=16*4;c5=16*5;c6=16*6;c7=16*7;c8=16*8;c9=16*9; c10=16*10;c11=16*11;c12=16*12;c13=16*13;c14=16*14;c15=16*15;c16=16*16; c17=16*17;c18=16*18;c19=16*19;c20=16*20;c21=16*21;c22=16*22;c23=16*23; c24=16*24;c25=16*25;c26=16*26;c27=16*27;c28=16*28;c29=16*29;c30=16*30; c31=16*31;c32=16*32;c33=16*33;c34=16*34;c35=16*35; } function draw(){ background(\u0026#34;white\u0026#34;); //line(0,y,width,y); //line(x,0,x,height); fill(\u0026#39;red\u0026#39;); stroke(\u0026#39;red\u0026#39;); circle(x,y,5); stroke(\u0026#39;black\u0026#39;); cuadro(x,y,c1);cuadro(x,y,c2);cuadro(x,y,c3);cuadro(x,y,c4); cuadro(x,y,c5);cuadro(x,y,c6);cuadro(x,y,c7);cuadro(x,y,c8); cuadro(x,y,c9);cuadro(x,y,c10);cuadro(x,y,c11);cuadro(x,y,c12); cuadro(x,y,c13);cuadro(x,y,c14);cuadro(x,y,c15);cuadro(x,y,c16); cuadro(x,y,c17);cuadro(x,y,c18);cuadro(x,y,c19);cuadro(x,y,c20); cuadro(x,y,c21);cuadro(x,y,c22);cuadro(x,y,c23);cuadro(x,y,c24); cuadro(x,y,c25);cuadro(x,y,c26);cuadro(x,y,c27);cuadro(x,y,c28); cuadro(x,y,c29);cuadro(x,y,c30);cuadro(x,y,c31);cuadro(x,y,c32); cuadro(x,y,c33);cuadro(x,y,c34);cuadro(x,y,c35); c1+=16;c2+=16;c3+=16;c4+=16;c5+=16;c6+=16;c7+=16;c8+=16;c9+=16;c10+=16; c11+=16;c12+=16;c13+=16;c14+=16;c15+=16;c16+=16;c17+=16;c18+=16;c19+=16; c20+=16;c21+=16;c22+=16;c23+=16;c24+=16;c25+=16;c26+=16;c27+=16;c28+=16; c29+=16;c30+=16;c31+=16;c32+=16;c33+=16;c34+=16;c35+=16; if(c35 \u0026gt; 560){c35 = 0;}if(c34 \u0026gt; 560){c34 = 0;}if(c33 \u0026gt; 560){c33 = 0;} if(c32 \u0026gt; 560){c32 = 0;}if(c31 \u0026gt; 560){c31 = 0;}if(c30 \u0026gt; 560){c30 = 0;} if(c29 \u0026gt; 560){c29 = 0;}if(c28 \u0026gt; 560){c28 = 0;}if(c27 \u0026gt; 560){c27 = 0;} if(c26 \u0026gt; 560){c26 = 0;}if(c25 \u0026gt; 560){c25 = 0;}if(c24 \u0026gt; 560){c24 = 0;} if(c23 \u0026gt; 560){c23 = 0;}if(c22 \u0026gt; 560){c22 = 0;}if(c21 \u0026gt; 560){c21 = 0;} if(c20 \u0026gt; 560){c20 = 0;}if(c19 \u0026gt; 560){c19 = 0;}if(c18 \u0026gt; 560){c18 = 0;} if(c17 \u0026gt; 560){c17 = 0;}if(c16 \u0026gt; 560){c16 = 0;}if(c15 \u0026gt; 560){c15 = 0;} if(c14 \u0026gt; 560){c14 = 0;}if(c13 \u0026gt; 560){c13 = 0;}if(c12 \u0026gt; 560){c12 = 0;} if(c11 \u0026gt; 560){c11 = 0;}if(c10 \u0026gt; 560){c10 = 0;}if(c9 \u0026gt; 560){c9 = 0;} if(c8 \u0026gt; 560){c8 = 0;}if(c7 \u0026gt; 560){c7 = 0;}if(c6 \u0026gt; 560){c6 = 0;} if(c5 \u0026gt; 560){c5 = 0;}if(c4 \u0026gt; 560){c4 = 0;}if(c3 \u0026gt; 560){c3 = 0;} if(c2 \u0026gt; 560){c2 = 0;}if(c1 \u0026gt; 560){c1 = 0;} } function cuadro(x,y,ct){ line(x-ct,y,x,y-ct); line(x,y-ct,x+ct,y); line(x-ct,y,x,y+ct); line(x,y+ct,x+ct,y); } {{\u0026lt; /p5-global-iframe \u0026gt;}} Estrella # En este lugar se puede encontrar la ilusión óptica original: this reference\ncódigo estrella {{\u0026lt; p5-global-iframe id=\u0026#34;breath\u0026#34; width=\u0026#34;625\u0026#34; height=\u0026#34;625\u0026#34; \u0026gt;}} // Coded as `global mode` of [this](https://github.com/VisualComputing/Cognitive/blob/gh-pages/sketches/rotateSquare.js) let h; let w; let perc1; let perc2; let perc3; function setup() { createCanvas(400, 400); h=float(0.9); w=float(width/2); perc1=0.05; perc2=0.0125; perc3=0.1; } function draw() { background(220); let num = 26; let num1 = 1; while (num \u0026gt; 0) { if (num % 2==0) { fill(0,0,0); } else { fill(255,255,255) } num = num - 1; square(w*0.0125+w+perc1*w*num1/30,w*perc2+w+perc1*w*num1/30,w*h-num1); square(-w*perc2+(1-h)*w+perc3*w*num1/30,+w*perc2+w+perc1*w*num1/30,w*h-num1); square(w*perc2+w+perc1*w*num1/30,+w*0.085+perc3*w*num1/30,w*h-num1); square(-w*perc2+(1-h)*w+perc3*w*num1/30,+w*0.085+perc3*w*num1/30,w*h-num1); num1 = num1+ 7; } } {{\u0026lt; /p5-global-iframe \u0026gt;}} Estrella ajustable # En este lugar se puede encontrar la ilusión óptica original: this reference\ncódigo estrella {{\u0026lt; p5-global-iframe id=\u0026#34;breath\u0026#34; width=\u0026#34;625\u0026#34; height=\u0026#34;625\u0026#34; \u0026gt;}} // Coded as `global mode` of [this](https://github.com/VisualComputing/Cognitive/blob/gh-pages/sketches/rotateSquare.js) let h; let w; let perc1; let perc2; let perc3; let slider; let slider1; let slider2; function setup() { createCanvas(400, 400); h=float(0.9); w=float(width/2); slider=createSlider(0, 0.15, 0.03, 0.01); slider2=createSlider(0, 0.15, 0.12, 0.01); } function draw() { background(255); perc1 = slider.value(); perc2=0.0125; perc3=slider2.value(); let num = 26; let num1 = 1; while (num \u0026gt; 0) { if (num % 2==0) { fill(0,0,0); } else { fill(255,255,255) } num = num - 1; square(w*0.0125+w+perc1*w*num1/30,w*perc2+w+perc1*w*num1/30,w*h-num1); square(-w*perc2+(1-h)*w+perc3*w*num1/30,+w*perc2+w+perc1*w*num1/30,w*h-num1); square(w*perc2+w+perc1*w*num1/30,+w*0.085+perc3*w*num1/30,w*h-num1); square(-w*perc2+(1-h)*w+perc3*w*num1/30,+w*0.085+perc3*w*num1/30,w*h-num1); num1 = num1+ 7; } } {{\u0026lt; /p5-global-iframe \u0026gt;}} "},{"id":2,"href":"/showcase/docs/shortcodes/taller1/Masking/","title":"Masking","section":"Taller1","content":" Masking # Un kernel es una mask que se usa para aplicar filtros a una imagen. Estas máscaras tienen forma de matriz cuadrada, por lo que también se denominan matrices de convolución.\nConsideremos la matriz A, que representa la matriz que contiene los valores de gris de todos los píxeles de la imagen original, y la matriz B que representa la matriz kernel. Ahora superpongamos la matriz A con la matriz B, de modo que el centro de la matriz B corresponda al píxel de la matriz A que se procesará.\nEl valor de la imagen objetivo (matriz C) se calcula como la suma de todos los elementos de la matriz resultante del producto de Hadamard entre las matrices A y B.\nRecordamos que el producto de Hadamard es una operación binaria que toma dos matrices de la misma dimensione y produce otra matriz de igual dimensión, donde cada elemento i , j es el producto de los elementos i , j de las dos matrices originales\nLook at this reference for an explanation and further parameterization of the illusion.\ncódigo moving picture {{\u0026lt; p5-global-iframe id=\u0026#34;breath\u0026#34; width=\u0026#34;800\u0026#34; height=\u0026#34;600\u0026#34; \u0026gt;}} // Coded as `global mode` of [this](https://github.com/VisualComputing/Cognitive/blob/gh-pages/sketches/rotateSquare.js) let tab; //menu de seleccion let selec; let img; let c1=0;let c2=0;let c3=0;let c4=0; function setup() { var canvas = createCanvas(800,600); background(209); canvas.drop(gotFile); tab= createSelect(); tab.position(10, 10); tab.option(\u0026#39;Masking\u0026#39;); tab.option(\u0026#39;-gris\u0026#39;); tab.option(\u0026#39;-invert\u0026#39;); tab.option(\u0026#39;-threshold\u0026#39;); tab.option(\u0026#39;-blur\u0026#39;); tab.option(\u0026#39;-erode\u0026#39;); tab.option(\u0026#39;-dilate\u0026#39;); tab.option(\u0026#39;-sin filtro\u0026#39;); tab.changed(pickEvent); } function gotFile(file) { img = createImg(file.data); img.hide(); image(img,0,0,800,600); } function pickEvent() { selec = tab.value(); if (selec === \u0026#39;-gris\u0026#39;) { selec = 1; } else if (selec === \u0026#39;-invert\u0026#39;) { selec = 2; } else if (selec === \u0026#39;-threshold\u0026#39;) { selec = 3; } else if (selec === \u0026#39;-blur\u0026#39;) { selec = 4; } else if (selec === \u0026#39;-erode\u0026#39;) { selec = 5; } else if (selec === \u0026#39;-dilate\u0026#39;) { selec = 6; } else if (selec === \u0026#39;-sin filtro\u0026#39;) { selec = 0; } } function canva(){ createCanvas(800,600); background(209); image(img,0,0,800,600); } function draw(){ if (selec == 1){ c1=0;c2=0;c3=0;c4=0; canva(); filter(GRAY); //escala de grises } else if (selec == 2){ c1=0;c2=0;c3=0; c4 = c4+1; if (c4 == 1){ canva(); filter(INVERT); } } else if (selec == 3){ c1=0;c2=0;c3=0;c4=0; canva(); filter(THRESHOLD); //píxeles en blanco y negro umbral } else if (selec == 4){ c2=0;c3=0;c4=0; c1 = c1+1; if (c1 == 1){ canva(); filter(BLUR,3); //desenfoque } } else if (selec == 5){ c1=0;c3=0;c4=0; c2 = c2+1; if (c2 == 1){ canva(); filter(ERODE) //reduce las areas claras } } else if (selec == 6){ c2=0;c1=0;c4=0; c3 = c3+1; if (c3 == 1){ canva(); filter(DILATE ); //aumenta las areas claras } } else if (selec == 0){ c1=0;c2=0;c3=0;c4=0; canva(); } } {{\u0026lt; /p5-global-iframe \u0026gt;}} histograma # Look at histograma for an explanation and further parameterization of the illusion.\ncódigo moving picture {{\u0026lt; p5-global-iframe id=\u0026#34;breath\u0026#34; width=\u0026#34;800\u0026#34; height=\u0026#34;600\u0026#34; \u0026gt;}} https://editor.p5js.org/crubioa/sketches/bpE30XhKL {{\u0026lt; /p5-global-iframe \u0026gt;}} Referencias # Making Filters Using p5.js! Kernel convolution Histograma filter Footer "}]